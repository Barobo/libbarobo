\documentclass{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{float}
\usepackage[left=1in,top=1in,right=1in]{geometry}

\title{Programming the MoBot}  
%\author{David Ko\\Mechanical and Aerospace Engineering}
%\date{\today} 
\makeindex

\begin{document}

\includegraphics[width=2in]{images/Barobo.png}
\hrule
\begin{center}
\vspace*{2.5cm}
{\Huge\sf\bf MoBot User's Guide}\\
\vspace*{2.5cm}
{\Large\bf Version 1.2}
\vspace{4.5cm}

\includegraphics[width=4in]{images/imobot_module.jpg}
\end{center}

%\maketitle
\newpage
\tableofcontents
\newpage
\section{The \texttt{CMobot} MoBot Remote Control Library}
The \texttt{CMobot} library is a collection of functions geared towards
controlling the motors and reading sensor values of a MoBot module via the
Bluetooth wireless protocol. The functions are designed to be intuitive
and easy to use. Various functions are provided to control or obtain the speed,
direction, and position of the motors. The API includes C++ classes called
\texttt{CMobot} and \texttt{CMobotGroup} to facilitate control of 
single and multiple MoBots.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/joint_diagram_verbose.png}
\end{center}
\caption{\label{fig:joint_diagram_verbose.png} A schematic diagram of a MoBot module.}
\end{figure}

Figure \ref{fig:joint_diagram_verbose.png} shows a schematic diagram displaying the
locations and positive directions of the four joints of a MoBot module. The
joints 1 and 4 shown in the figure are fully rotational and have no joint limits.
Joints 2 and 3, however, can only move in the range -90 to +90 degrees.

This documentation introduces the basic computer setup required for controlling 
the MoBot, as well as several demo programs and a complete reference for all
API function provided with the \texttt{CMobot} and \texttt{CMobotGroup} library.

\section{\label{sec:pairing}Configuring MoBots for Remote Control}
MoBot modules should be configured the first time they are used with 
a new computer. The process informs the computer which MoBots it
is allowed to connect to. The is also necessary for certain 
functions in the \texttt{CMobot} API, such as \texttt{connect()},
to determine which robots to connect to.

The configuration is performed through the Barobo RobotController
program. The remainder of the section contains step-by-step instructions
and screenshots showing how to configure your MoBots.

To start the provided Barobo Robot Control Program click on the icon labeled 
``RobotController'' on your desktop. The 
control dialog as shown in Figure \ref{fig:shot1.png} should pop up.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot1.png}
\end{center}
\caption{\label{fig:shot1.png} The graphical user interface of the RobotController.}
\end{figure}

\subsection{Adding Bluetooth Addresses of Robots in RobotController.}
Click on the menu item ``Configure $\rightarrow$ Configure Robot Bluetooth'', as
shown in Figure \ref{fig:shot3.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot3.png}
\end{center}
\caption{\label{fig:shot3.png} Configuring robot bluetooth connection.}
\end{figure}

This should bring up a second dialog, titled ``Configure Robot Bluetooth'', as
shown in Figure \ref{fig:shot4.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot4.png}
\end{center}
\caption{\label{fig:shot4.png} The dialog window for bluetooth connection.}
\end{figure}

This dialog allows us to add robot bluetooth addresses to the list of currently
known robot bluetooth addresses. To add an address, first type in the address
in the text box on the top of the dialog, as shown in Figure \ref{fig:shot5.png}.
You can find the bluetooth address of each robot inside the battery compartment
of the robot on the same side as the power switch. 

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot5.png}
\end{center}
\caption{\label{fig:shot5.png} Adding the robot bluetooth address in the dialog window.}
\end{figure}

Next, click the ``Add'' button. The newly added address should appear in the 
list of known addresses, as shown in Figure \ref{fig:shot6.png}. In our case, we have added the 
address of one of our robots, which is \texttt{"00:06:66:43:0E:02"}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot6.png}
\end{center}
\caption{\label{fig:shot6.png} Displaying the added bluetooth address.}
\end{figure}

We use the same process to add our remaining two robots to the list,
with addresses \texttt{"00:06:66:43:0D:F2"} and 
\texttt{"00:06:66:47:23:9C"}. The dialog now appears as shown in
Figure \ref{fig:shot8.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot8.png}
\end{center}
\caption{\label{fig:shot8.png} Displaying bluetooth addresses for three robots.}
\end{figure}

The dialog also allows users to reorder the addresses listed. The
order the addresses are listed in affects the order in which the robots
are connected to using the \texttt{connect()} member function. 
The remote control dialog connects to the primary address located at the
top of the list by default. To reorder the list of addresses, simply
select the address to move and click on the ``Move Up'' or ``Move Down''
button to either move the address higher in the list or lower. For instance,
the result of clicking on the address \texttt{"00:06:66:43:0D:F2"} and clicking
the ``Move Up'' button is shown in Figure \ref{fig:shot10.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot10.png}
\end{center}
\caption{\label{fig:shot10.png} The graphical user interface of the RobotController.}
\end{figure}

\subsection{Connecting and Disconnecting to Robots from the RobotController}
Once bluetooth addresses are added to the RobotController, you may connect to the 
first address by clicking on the ``Connect $\rightarrow$ Connect to Robot''
menu item. The connected robot may be disconnected by clicking on the 
``Connect $\rightarrow$ Disconnect from Robot'' menu item. Any connected robots are
automatically disconnected upon exiting the program.

\section{ The Robot Remote Control Program }
\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot1_populated.png}
\end{center}
\caption{\label{fig:shot1_populated.png} The graphical display of the RobotController
while connected to a robot.}
\end{figure}

Once a robot is connected to the RobotController, the joint angles and speeds
of the robot are displayed as shown in Figure \ref{fig:shot1_populated.png}.
The RobotController can then be
used to display
information about the MoBot's joint positions, and also control the
speeds and positions of the MoBot's joints. The interface is divided
up into six sections; three on the top half of the interface, and three on 
the bottom half. 

\subsection{The MoBot Diagram and ``Move To Zero'' Button}
The first section of the GUI located on the top left of the interface
displays a schematic diagram of the MoBot, displaying motor positions.
Underneath the diagram, there is a large button with the text 
``Move To Zero''. When clicked, this button will command the connected
MoBot to rotate all of its joints to a flat ``Zero'' position.

\subsection{Individual Joint Control}
The second section, located at the top-middle section of the interface,
is the ``Individual Joint Control'' section. These buttons command the
MoBot to move individual joints. When the up or down arrows are clicked,
the MoBot begins to move the corresponding joint in either the positive,
or negative direction. The joint will continue to move until the stop 
button, located between the up and down arrows, is clicked. 

If the joint encounters any obstacle that prevents it from moving, the 
joint will automatically disengage power to the joint. This may happen, 
example, if a body joint attempts to rotate beyond its limits,
or if it collides with the other corresponding body joint. 

\subsection{Rolling Control}
This section contains buttons for controlling the MoBot as a 
two wheeled mobile robot. The up and down buttons cause the MoBot to
roll forward or backward. The left and right buttons cause the MoBot 
to rotate towards the left, or towards the right. The stop button in the
middle causes the MoBot to stop where it is.

\subsection{Joint Speeds}
The ``Joint Speeds'' section, located at the bottom left of the interface,
displays and controls the current joint speeds of the MoBot. Joint speeds
are a value between 0 and 1, with 1 meaning maximum joint power, and 0
meaning zero joint power. The speed may be set by sliding the vertical 
sliders to the desired positions. 

\subsection{Joint Positions}
This section, located in the bottom-middle of the interface, is used to display
and control the positions of each of the four
joints of a MoBot. The joint positions are displayed in the numerical
text located above each vertical slider. The displayed joint positions are in
units of degrees.  
%There are two methods to control the joints using this interface.

The method of controlling the joints is by using the vertical sliders.
Each vertical slider's position represents a joint's angle. The sliders for the
two end joints vary from -180 degrees to 180 degrees, representing one complete
rotation. The angles for the two body joints vary from -90 to 90 degrees. When
the position of the slider is moved, the MoBot will move its joints to match the 
sliders. 

Underneath the sliders, there are four text entry boxes. The text boxes
accept specific angles for each joint which the user may type in. When 
the ``Move'' button is clicked, each joint will move to their respective 
desired positions. If any text entry is left blank, the joint will
not move. 
\begin{comment}
The second method for moving the joints is by entering the exact angles for the
joints. Below each of the four sliders lies a text entry box. Values in degrees
may be typed into each of the four entry boxes. When the button on the lower
right of the section labeled ``Move'' is clicked, the MoBot will move its joints
to match the values typed into the boxes. If no value is typed into a box, that 
joint will not move.
\end{comment}

\subsubsection{Joint Limits}
Joints 1 and 4 are fully rotational and have no joint limits. Joints 2 and 3, however, are 
limited to a range of -90 to +90 degrees.

\subsection{Motions}
This section, located on the bottom right of the interface, contains a set of
preprogrammed motions for the MoBot. To execute a preprogrammed motion, simply
click on the name of the motion you wish to execute, and then click the button
labeled ``Play''.

\section{Getting Started Programming the MoBot}
The first demo presents a minimal program which connects to a MoBot and
moves some joints.

Before the Ch program is executed, the Bluetooth addresses of the robots
need to be added using the RobotController as described in Section \ref{sec:pairing}.
If a robot is already connected to the RobotController, disconnect
from the robot before running the Ch program, or close the RobotController application.

\subsection{\texttt{start.ch}, A Basic Ch Mobot Program}
\subsubsection{\texttt{start.ch} Source Code}
\verbatiminput{../demos/chdemos/start.ch}

\subsubsection{\label{sec:democode}Demo Code for \texttt{start.ch} Explained}
The beginning of every MoBot control program will include header files. Each
header file imports functions used for a number of tasks, such as printing
data onto the screen or controlling the MoBot. The \texttt{mobot.h} header
file must be included in order to use the \texttt{CMobot} class and related
robotic control functions.

\begin{verbatim}
#include <mobot.h> // Required for MoBot control functions
\end{verbatim}

Next, we must initialize the C++ class used to control the MoBot. 

\begin{verbatim}
CMobot robot;
\end{verbatim}

This line
initializes a new variable named \texttt{robot} which represents the remote
MoBot module which we wish to control. This special variable is actually an
instance of the \texttt{CMobot} class, which contains its own set of
functions called ``methods'' or ``member functions''.

Next, we initialize two \texttt{double} type variables called 
``angle1'' and ``angle4'', which we will use to store joint angles by the
statement below.
\begin{verbatim}
double angle1, angle4;
\end{verbatim}

The next line,
\begin{verbatim}
robot.connect();
\end{verbatim}
will connect our new variable, \texttt{robot}, to a
MoBot that has been previously configured with the computer in the 
process described in Section \ref{sec:pairing}.

Note that there are two common methods to connect to a remote MoBot. 
The most common method, demonstrated in the previous line of code, is
used to connect to a MoBot that is already paired to the computer. It
is also possible to connect to MoBots which are not paired with the 
computer. This method is necessary for connecting to multiple
MoBots simultaneously, as only a single MoBot may be paired with the
computer at a time. The second method uses the function
\texttt{connectWithAddress()}, and its default usage is as such:
\begin{verbatim}
string_t address = "11:22:33:44:55:66";
int defaultChannel = 1;
robot.connectWithAddress(address, defaultChannel);
\end{verbatim}
The string \texttt{"11:22:33:44:55:66"} represents the Bluetooth address
of the MoBot, which must be known in advance. The channel number \texttt{1} 
represents the Bluetooth channel to connect to. Channel \texttt{1}
is the default channel MoBots listen on for incoming connections, but
may be set to other values depending on the type of robot. Detailed
documentation for each of the MoBot functions, such as 
\texttt{connect()} and \texttt{connectAddress()}, are presented in
Appendix \ref{sec:cmobot_api}.

The next line,
\begin{verbatim}
robot.moveToZero();
\end{verbatim}
uses the \texttt{moveToZero()} member function. The
\texttt{moveToZero} function causes the MoBot to move all of its motors to the
zero position.

The next lines of code command joints 1 and 4 to rotate 360 degrees.
\begin{verbatim}
angle1 = deg2rad(360);
angle4 = deg2rad(360);
robot.move(angle1, 0, 0, angle4);
\end{verbatim}
Note that the member function \texttt{move()} expects input angles
in radians, so the angles in degrees must be converted to radians
using the \texttt{deg2rad()} function. The \texttt{deg2rad()} function
takes an angle in degrees as its argument and returns the angle in
radians. The function is implemented in Ch with the code
\begin{verbatim}
#include<math.h>
double deg2rad(double degrees)
{
    double radians;
    radians = degrees * M_PI / 180.0;
    return radians;
}
\end{verbatim}

If desired, values in radians
may also be converted to degrees using the counterpart function,
\texttt{rad2deg()}.
Joints 1 and 4 are the faceplates
of the MoBot which are sometimes used to act as "wheels".

\subsection{\texttt{returnval.ch}, A Basic Ch Mobot Program Which Checks Return Values}
\verbatiminput{../demos/chdemos/returnval.ch}

\section{Controlling the Speed of Mobot Joints}
\verbatiminput{../demos/chdemos/setspeed.ch}

\section{Preprogrammed Motions}
The robot API contains functions for executing preprogrammed motions. The 
preprogrammed motions are motions which are commonly used for robot locomotion.
Following is a list of available functions and a brief description about
their effect on the robot.
\begin{itemize}
\item \texttt{motionArch()}: This function causes the robot to arch up for better 
clearance.
\item \texttt{motionInchwormLeft()}: This function causes the robot to perform
  the inchworm gait once, moving the robot towards its left.
\item \texttt{motionInchwormRight()}: This function causes the robot to perform
  the inchworm gait once, moving the robot towards its right.
\item \texttt{motionRollBackward()}: This function causes the robot to rotate
  its faceplates, using them as wheels to roll backward.
\item \texttt{motionRollForward()}: This function causes the robot to rotate
  its faceplates, using them as wheels to roll forward.
\item \texttt{motionSkinny()}: This function makes the robot assume a skinnier
rolling profile.
\item \texttt{motionStand()}: This function causes the robot to stand up onto a 
  faceplate, assuming the camera platform position.
\item \texttt{motionTumble()}: This function causes the robot to perform the
tumbling motion, flipping end over end.
\item \texttt{motionTurnLeft()}: Uses the robot's faceplates as wheels, turning
  them in opposite directions in order to rotate the robot towards its left.
\item \texttt{motionTurnRight()}: Uses the robot's faceplates as wheels, turning
  them in opposite directions in order to rotate the robot towards its right.
\item \texttt{motionUnstand()}: Causes the robot to drop down from a standing position.
\end{itemize}

Note that all of the functions listed above are ``blocking'' functions, meaning
they will not return until the motion has completed. These functions also
have non-blocking equivalents which are discussed in Section
\ref{sec:blocking}.

\subsection{\texttt{inchworm.ch}: A Demo using the \texttt{motionInchwormLeft()}
Preprogrammed Motion}
\subsubsection{\texttt{inchworm.ch} Source Code}
\verbatiminput{../demos/chdemos/inchworm.ch}
\subsubsection{\texttt{inchworm.ch} Explained}
First, the header file \texttt{mobot.h} is included. This header file
is required before usage of the \texttt{CMobot} class and its associated
member functions can be used. Next, we create a variable to reperesent our
robot and connect to the robot with the following lines.
\begin{verbatim}
CMobot robot;

/* Connect to the paired MoBot */
robot.connect();
\end{verbatim}

Next, we set the motor speeds to 50\% speed with the following lines.
\begin{verbatim}
robot.setJointSpeedRatio(ROBOT_JOINT2, 0.50);
robot.setJointSpeedRatio(ROBOT_JOINT3, 0.50);
\end{verbatim}

\texttt{ROBOT\_JOINT2} and \texttt{ROBOT\_JOINT3} are enumerated values 
defined in the header file \texttt{mobot.h}. Detailed information
for all enumerated values defined in \texttt{mobot.h} can be found in 
Appendix \ref{sec:datatypes}.

We then move the robot to its zero position in preparation for the 
inchworm gait.
\begin{verbatim}
robot.moveToZero();
\end{verbatim}

Finally, we perform the inchworm gait four times. The argument for the
function \texttt{motionInchwormLeft()} reperesents the number of times
the gait should be performed.
\begin{verbatim}
robot.motionInchwormLeft(4);
\end{verbatim}


\subsection{\texttt{stand.ch}: A Demo Using the \texttt{motionStand()} Preprogrammed
Motion}
This demo is a simple demonstration of the \texttt{motionStand()} member function.
\subsubsection{\texttt{stand.ch} Source Code}
\verbatiminput{../demos/chdemos/stand.ch}
\subsubsection{\texttt{stand.ch} Explained}
After the initialization and 
connection as seen in the previous demo, it executes the following line of
code:
\begin{verbatim}
robot.motionStand();
\end{verbatim}
This line of code causes the MoBot to perform a sequence of motions causing it to
stand up on a faceplate. The function is a blocking function and will wait until
the entire motion sequence is completed before continuing. There are also non-blocking
versions of the motion functions, documented in Section \ref{sec:blocking}.

\subsection{\texttt{tumble.ch}: A Demo Using the \texttt{motionTumble()} Preprogrammed
Motion}
\verbatiminput{../demos/chdemos/tumble.ch}

\subsection{\texttt{motion.ch}: A Demo Using Multiple Preprogrammed Motions}
\verbatiminput{../demos/chdemos/motion.ch}

\section{Detailed Examples of Custom Motions}
To help the user become acquainted with the MoBot control programs, sample
programs will be presented in this section to illustrate the basics and minimum requirements of
a MoBot control program. The sample programs are located at 
\texttt{CHHOME/package/chmobot/demos}, where \texttt{CHHOME} is the 
Ch home directory, such as \texttt{C:$\backslash$Ch} for Windows. For Windows,
it is located at \texttt{C:$\backslash$Ch$\backslash$package$\backslash$chmobot$\backslash$demos} by default. 

\subsection{Inchworm Gait Demo}
The next demo will illustrate how a simple gait known as the ``Inchworm'' gait 
can be implemented.

\subsubsection{\texttt{inchworm2.ch} Source Code}
\verbatiminput{../demos/chdemos/inchworm2.ch}

\subsubsection{Demo Code for \texttt{inchworm2.ch} Explained}
The first portion of the code is identical to the previous demo, and performs
the same function of declaring a MoBot variable and connecting to a 
paired MoBot.
\begin{verbatim}
#include <mobot.h>

CMobot robot;

/* Connect to the paired MoBot */
robot.connect();
\end{verbatim}

The next lines of code set the joint speeds for the two body joints, joints 
two and three, to 50\% speed. They are set to fifty percent speed in order to 
slow the motion down in order to minimize slippage.

\begin{verbatim}
/* Set robot motors to speed of 0.50 */
robot.setJointSpeedRatio(ROBOT_JOINT2, 0.50);
robot.setJointSpeedRatio(ROBOT_JOINT3, 0.50);
\end{verbatim}

Next, we move the robot into a flat ``zero'' position.

\begin{verbatim}
/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();
\end{verbatim}

Finally, we perform the actual inchworm motion. The inchworm motion is a gait defined
by a sequence of motions performed by the body joints. The motions are as such:
\begin{enumerate}
\item The first body joint, referred to as joint A, rotates towards the ground.
This drags the MoBot towards the direction of joint A.
\item The other body joint, joint B, rotates towards the ground. Since the center
of gravity is currently positioned over joint A, this causes the trailing body 
joint to slide toward joint A.
\item Joint A moves back to a flat position.
\item Joint B moves back to a flat position.
\item Repeat, if desired.
\end{enumerate}
The direction of travel depends on the selection of the initial body joint. In
the following code example, joint 2 is chosen as the initial body joint to move.
In this case, the MoBot will traverse towards joint 2. The entire motion is
encapsulated in a ``for'' loop which executes the entire motion four times.
\begin{verbatim}
/* Do the inchworm gait four times */
int i, num = 4;
double angle2 = deg2rad(-45);
double angle3 = deg2rad(45);
for(i = 0; i < num; i++) {
    robot.moveJointTo(ROBOT_JOINT2, angle2);
    robot.moveJointTo(ROBOT_JOINT3, angle3);
    robot.moveJointTo(ROBOT_JOINT2, 0);
    robot.moveJointTo(ROBOT_JOINT3, 0);
}
\end{verbatim}
The values of the variables \texttt{angle2} and \texttt{angle3} may also be modified
to produce different variations of the inchworm gait to accomodate different terrain
textures and ground surfaces.

\subsection{Standing Demo}
\subsubsection{\texttt{stand2.ch} Source Code}
\verbatiminput{../demos/chdemos/stand2.ch}
\subsubsection{\texttt{stand2.ch} Explained}
The first portion of the program performs the necessary setup and connecting,
similar to the previous demos. Similar to the previous inchworm demo, the
motor speeds are set to a speed of 90 degrees per second, and the function \texttt{moveToZero()} is
called to put the robot into a flat position. Next, the following lines
are executed:
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT2, deg2rad(-85));
robot.moveJointTo(ROBOT_JOINT3, deg2rad(70));
\end{verbatim}
These movement commands cause the MoBot to curl up into a fetal position with
both of its endplates facing toward the ground. The next line, 

\begin{verbatim}
sleep(1);
\end{verbatim}
causes the program to pause for one second before continuing. This allows the
robot to settle down, in case it was still in motion from the last movement.

Next, the MoBot rotates one 
of the endplates by 45 degrees. 
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT1, deg2rad(45));
\end{verbatim}
This endplate will eventually become the ``foot'' of the standing MoBot. Next,
the MoBot lifts itself into a standing position, balancing on its endplate.
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT2, deg2rad(20));
\end{verbatim}
Note that the previous joint angle for Joint 2, a body joint, was -85 degrees. 
This motion causes joint 2 to rotate all the way to a 20 degree position, which
lift up the body of the MoBot such that the MoBot is balancing on faceplate joint 1.

Finally, we rotate joint 1, the foot joint, for three seconds which causes the
entire MoBot to rotate in place. The speed is first set to 45 degrees per second to make the
rotation a slow rotation. Next, the \texttt{moveContinuousTime} member function
is used to continuously rotate a joint for a desired amount of time.
\begin{verbatim}
robot.setJointSpeed(ROBOT_JOINT1, deg2rad(45));
robot.moveContinuousTime(ROBOT_FORWARD, ROBOT_HOLD, ROBOT_HOLD, 
                         ROBOT_HOLD, 3000);
\end{verbatim}

The macros \texttt{ROBOT\_FORWARD} and \texttt{ROBOT\_BACKWARD}
indicate the directions for each motor to turn. The macro
\texttt{ROBOT\_NEUTRAL} indicates that the motor should not turn, but
should remain flexible and backdrivable. The macro \texttt{ROBOT\_HOLD}
indicates that the joint will not turn, and that the joint will be 
forcefully held in place at its current position. More information regarding these
macros may be found in Section \ref{sec:robotJointState_t}.

\subsection{Tumbling Demo}
\verbatiminput{../demos/chdemos/tumble2.ch}

\section{\label{sec:blocking}Blocking and Non-Blocking Functions}
All of the MoBot movement functions may be designated as either ``blocking'' 
functions or ``non-blocking'' functions. A blocking function is a function which
does not return while operations are being performed. All standard C functions,
such as \texttt{printf()}, are blocking functions. The
\texttt{moveWait()} function is a blocking function. When called, the function
will hang, or ``block'', until all the joints have stopped moving. After all
joints have stopped moving, the \texttt{moveWait()} function will return, and 
the rest of the program will execute.

Furthermore, some functions have both a blocking version and a non-blocking
version. For these functions, the suffix \texttt{NB} denotes that the function
is non-blocking. For instance, the function \texttt{motionStand()} is blocking,
meaning the function will not return until the motion is completed, whereas
the function \texttt{motionStandNB()} is non-blocking, meaning the function
returns immediately and the robot performs the ``standing'' motion
asynchronously.

The function \texttt{moveNB()} is an example of a non-blocking function. When
the \texttt{moveNB()} function is called, the function immediately returns 
as the joints begin moving. Any lines of code following the call to 
\texttt{moveNB()} will be executed even if the current motion is still in
progress. 

Demos for the non-blocking functions are located in the next section of
this document.

\subsection{List of Blocking Movement Functions}
\begin{itemize}
\item \texttt{move()}
\item \texttt{moveContinuousTime()}
\item \texttt{moveJointTo()}
\item \texttt{moveTo()}
\item \texttt{moveToZero()}
\item \texttt{moveJointWait()}
\item \texttt{moveWait()}
\item \texttt{motionArch()}
\item \texttt{motionInchwormLeft()}
\item \texttt{motionInchwormRight()}
\item \texttt{motionRollBackward()}
\item \texttt{motionRollForward()}
\item \texttt{motionSkinny()}
\item \texttt{motionStand()}
\item \texttt{motionTumble()}
\item \texttt{motionTurnLeft()}
\item \texttt{motionTurnRight()}
\item \texttt{motionUnstand()}
\end{itemize}

\subsection{List of Non-Blocking Movement Functions}
\begin{itemize}
\item \texttt{moveNB()}
\item \texttt{moveContinuousNB()}
\item \texttt{moveJointToNB()}
\item \texttt{moveToNB()}
\item \texttt{moveToZeroNB()}
\item \texttt{motionArchNB()}
\item \texttt{motionInchwormLeftNB()}
\item \texttt{motionInchwormRightNB()}
\item \texttt{motionRollBackwardNB()}
\item \texttt{motionRollForwardNB()}
\item \texttt{motionSkinnyNB()}
\item \texttt{motionStandNB()}
\item \texttt{motionTumbleNB()}
\item \texttt{motionTurnLeftNB()}
\item \texttt{motionTurnRightNB()}
\item \texttt{motionUnstandNB()}
\end{itemize}

\subsection{Blocking and Non-Blocking Demo Programs}
\verbatiminput{../demos/chdemos/nonblock.ch}
\verbatiminput{../demos/chdemos/nonblock2.ch}
\verbatiminput{../demos/chdemos/nonblock3.ch}

\section{Controlling Multiple Modules}
The MoBot control software is designed to be able to control multiple modules
simultaneously. There are a couple important differences in the program 
which enable the control of multiple modules. A small demo program which
controls two modules simultaneously will first be presented, followed by
a detailed explanation of the program elements.

\subsection{\texttt{multipleModules.ch} Source Code}
\verbatiminput{../demos/chdemos/multipleModules.ch}

\subsection{Demo Explanation}
The first two lines of interest appear as such:
\begin{verbatim}
  CMobot robot1;
  CMobot robot2;
\end{verbatim}
These two lines declare two separate variables which will represent the
two separate MoBot modules. Next, we need to connect each variable to
a physically separate MoBot. This is done with the following lines.
\begin{verbatim}
  robot1.connect();
  robot2.connect();
\end{verbatim}
These two lines connect the robots to the first two addresses
of the known robot addresses. The list of the computer's known
robot addresses may be configured in the process detailed in Section
\ref{sec:pairing} on page \pageref{sec:pairing}. For each separate
control program, the first call to the \texttt{connect()} member
function will connect to the first robot listed in the configuration
file. Each successive call to the \texttt{connect()} function will
connect to successive robots listed in the configuration file. 
The order in which they are connected may be modified using the
``Configure Robot Bluetooth'' dialog, as discussed in Section
\ref{sec:pairing}.

\begin{verbatim}
  robot1.moveToZeroNB();
  robot2.moveToZeroNB();
\end{verbatim}
These two lines command the two robots to move to their zero positions.
Note that these functions are non-blocking. This means that the
\texttt{moveToZeroNB()} function will return immediately, and will not
wait for the first robot to finish completing the motion before 
commanding the second robot to begin. In a normal program, this effectively
causes both robots to move to their zero positions simultaneously.

\begin{verbatim}
  robot1.moveWait();
  robot2.moveWait();
\end{verbatim}
Since the \texttt{moveToZeroNB()} functions are non-blocking, we would like
the program to wait until the motions are complete before continuing. By
calling \texttt{moveWait()} on both of the robots, we can be assured that
the robots have finished moving before the program continues.

\begin{verbatim}
  robot1.motionStandNB();
  robot2.motionInchwormLeftNB();
  robot1.motionWait();
  robot2.motionWait();
\end{verbatim}
Similar to the calls to \texttt{moveToZeroNB()}, this block of code instructs 
the first MoBot to stand and the second MoBot to perform the inchworm gait.
Note that we call the non-blocking versions of the
functions, \texttt{motionStandNB()} and \texttt{motionInchwormLeftNB}. Since these functions are
non-blocking, both robots will effectively perform the motions simultaneously. 
Next, we call the member function \texttt{motionWait()} to wait for the motions
to finish before exiting the program.

\subsection{Controlling Multiple Connected Modules}
\subsubsection{\texttt{lift.ch}, Lifting Demo}
\verbatiminput{../demos/chdemos/lift.ch}

\section{Commanding Multiple Robots to Perform Identical Tasks}
There is a specialized class called \texttt{CMobotGroup} which may be used
to control multiple modules simultaneously. The \texttt{CMobotGroup} represents
a group of robots. Any command that is given to the group of modules is 
duplicated to each member of the group.

The majority of the movement functions available in the \texttt{CMobot} class
are also available in the \texttt{CMobotGroup} class. 
The detailed information for each member function are presented in 
Appendix \ref{sec:cmobot_api}.
 Following
is a complete listing of the available member functions in the \texttt{CMobotGroup}
class.

\begin{tabular}{p{4.5cm}p{8cm}} \hline 
Function Name & Description \\
\hline
\texttt{addRobot()} & Adds a robot to the group. \\
\texttt{move()} & Move joints on robots from their current positions for all robots in the group. \\
\texttt{moveContinuousNB()} & Move joints continuously for all robots in the group. \\
\texttt{moveContinunousTime()} & Move joints continuously for a specific amount of time for all robots in the group.\\
\texttt{moveJointContinuousNB()} & Move a single joint continuously for all robots in the group. \\
\texttt{moveJointContinuousTime()} & Move a single joint continuously for a specific amount of time for all robots in the group.\\
\texttt{moveJointTo()} & Move a joint to an absolute angle for all robots in the group.\\
\texttt{moveJointWait()} & Wait for a joint to finish moving for all robots in the group. \\
\texttt{moveTo()} & Move joints to a set of specific angles for all robots in the group. \\
\texttt{moveWait()} & Wait for all joints to finish moving. \\
\texttt{moveToZero()} & Move all joints to their zero positions. \\
\texttt{setJointSpeed()} & Set the speed of a joint, in radians per second. \\
\texttt{setJointSpeedRatio()} & Set the speed of a joint as a ratio of the maximum speed. \\
\texttt{setTwoWheelRobotSpeed()} & Move the robot at a linear speed, given the wheel size and desired speed.\\
\texttt{stop()} & Stop all the joints of all robots in the group. \\
\texttt{motionArch()} & Cause all robots in the group to arch for higher rolling clearance. \\
\texttt{motionArchNB()} & Cause all robots in the group to arch for higher rolling clearance. \\
\texttt{motionInchwormLeft()} & Cause all robots in the group to inchworm. \\
\texttt{motionInchwormLeftNB()} & Cause all robots in the group to inchworm. \\
\texttt{motionInchwormRight()} & Cause all robots in the group to inchworm. \\
\texttt{motionInchwormRightNB()} & Cause all robots in the group to inchworm. \\
\texttt{motionRollBackward()} & Makes all robots in the group roll backward. \\
\texttt{motionRollForwardNB()} & Makes all robots in the group roll forward. \\
\texttt{motionSkinny()} & Makes all robots in the group assume a skinny rolling profile. \\
\texttt{motionSkinnyNB()} & Makes all robots in the group assume a skinny rolling profile. \\
\texttt{motionStand()} & Makes all robots in the group stand. \\
\texttt{motionStandNB()} & Makes all robots in the group stand. \\
\texttt{motionTumble()} & Makes all the robots in the group perform the tumbling motion. \\
\texttt{motionTumbleNB()} & Makes all the robots in the group perform the tumbling motion. \\
\texttt{motionTurnLeft()} & Makes all robots in the group turn left. \\
\texttt{motionTurnLeftNB()} & Makes all robots in the group turn left. \\
\texttt{motionTurnRight()} & Makes all robots in the group turn right. \\
\texttt{motionTurnRightNB()} & Makes all robots in the group turn right.\\
\texttt{motionUnstand()} & Makes all robots in the group drop down from a standing position. \\
\texttt{motionUnstandNB()} & Makes all robots in the group drop down from a standing position. \\
\hline
\end{tabular}

\subsection{Demo program \texttt{group.ch}}
\subsubsection{Source Code}
\verbatiminput{../demos/chdemos/group.ch}

\subsubsection{Demo Explanation}
The first lines of interest appear as such:

\begin{verbatim}
CMobot robot1;
CMobot robot2;

CMobotGroup group;
\end{verbatim}

These lines declare two robot variables, and one variable which
will represent a group of robots. Next, we connect the robot
variables to their physical counterparts.

\begin{verbatim}
robot1.connect();
robot2.connect();
\end{verbatim}

Once they are connected, we wish to add both of these robots to our robot group,
which we have named \texttt{group}.

\begin{verbatim}
group.addRobot(robot1);
group.addRobot(robot2);
\end{verbatim}

Finally, we wish for all of the robots in our robot group, namely
\texttt{robot1} and \texttt{robot2}, to peform an inchworm motion four times, followed
by a standing motion. This is done with the following lines:

\begin{verbatim}
group.motionInchwormLeft(4); /* Cause both robots to inchworm left 4 times */
group.motionStand(); /* Cause both robots to stand */
\end{verbatim}

\newpage
\appendix
\section{\label{sec:datatypes}Data Types}
There are data types which are used by the MoBot library to represent 
certain values, such as joint id's and motor directions.

\begin{tabular}{p{3.5cm}p{10cm}} \hline 
Data Type& Description \\
\hline 
\texttt{robotJointId\_t} & An enumerated value that indicates a MoBot joint. \\
\texttt{robotJointState\_t} & The current state of a MoBot joint. \\
\hline
\end{tabular}

\subsection{\label{sec:robotJointId_t}\texttt{robotJointId\_t}}
This datatype is an enumerated type used to identify a joint on the MoBot. Valid
values for this type are:
\begin{verbatim}
typedef enum mobot_joints_e {
  ROBOT_JOINT1 = 1,
  ROBOT_JOINT2 = 2,
  ROBOT_JOINT3 = 3,
  ROBOT_JOINT4 = 4
} robotJointId_t;
\end{verbatim}
\index{robot\_joints\_t}

\index{ROBOT\_JOINT1}
\index{ROBOT\_JOINT2}
\index{ROBOT\_JOINT3}
\index{ROBOT\_JOINT4}
\begin{tabular}{p{3cm}p{10cm}} \hline 
Value & Description \\
\hline 
\texttt{ROBOT\_JOINT1} & Joint number 1 on the MoBot, which is a faceplate joint. \\
\texttt{ROBOT\_JOINT2} & Joint number 2 on the MoBot, which is a body joint. \\
\texttt{ROBOT\_JOINT3} & Joint number 3 on the MoBot, which is a body joint. \\
\texttt{ROBOT\_JOINT4} & Joint number 4 on the MoBot, which is a faceplate joint. \\
\hline
\end{tabular}

\subsection{\label{sec:robotJointState_t}\texttt{robotJointState\_t}}
This datatype is an enumerated type used to designate the current 
movement state of a joint. The values may be retrieved from the 
robot with the \texttt{getJointState()} function and may be set 
with the \texttt{moveContinuous()} family of functions. Valid values are:

\begin{verbatim}
typedef enum mobot_joint_state_e {
  ROBOT_NEUTRAL   = 0,
  ROBOT_FORWARD   = 1,
  ROBOT_BACKWARD  = 2,
  ROBOT_HOLD      = 3
} robotJointState_t;
\end{verbatim}

\begin{tabular}{p{3.3cm}p{11.5cm}} \hline 
Value & Description \\
\texttt{ROBOT\_NEUTRAL}& This value indicates that the joint is not moving and is not actuated. The joint is freely backdrivable. \\
\texttt{ROBOT\_FORWARD}& This value indicates that the joint is currently moving forward. \\
\texttt{ROBOT\_BACKWARD}& This value indicates that the joint is currently moving backward. \\
\texttt{ROBOT\_HOLD}& This value indicates that the joint is currently not moving and is holding its current position. The joint is not currently backdrivable. \\
\hline
\end{tabular}

\section{\label{sec:cmobot_api}CMobot API}
\input{api/libimobotcomms.tex}

\section{CMobotGroup API}
\input{cmobotgroup_api/cmobotgroup.tex}
% Index
%\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
