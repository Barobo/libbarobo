\documentclass{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{float}
\usepackage{subfig}
\usepackage[left=1in,top=1in,right=1in]{geometry}

\title{Programming the Mobot}  
%\author{David Ko\\Mechanical and Aerospace Engineering}
%\date{\today} 
\makeindex

\begin{document}

\includegraphics[width=2in]{images/Barobo.png}
\hrule
\begin{center}
\vspace*{2.5cm}
{\Huge\sf\bf Mobot User's Guide}\\
\vspace*{2.5cm}
{\Large\bf Version 1.3.6}
\vspace{4.5cm}

\includegraphics[width=4in]{images/Mobot_Camera_Stand.JPG}
\end{center}

\input{copyright}
%\maketitle
\newpage
\tableofcontents
\newpage
\section{Introduction}
The Mobot is a breakthrough modular robot. A single Mobot module is a fully 
functional robot capable of performing many possible motions. The Mobot
can als obe used as a building block to create robots with different
geometric configurations. 
This documentation introduces the basic computer setup required for controlling 
the Mobot, as well as several demo programs and a complete reference for all
API function provided with the \texttt{CMobot} and \texttt{CMobotGroup} library.

The \texttt{CMobot} library is a collection of functions geared towards
controlling the motors and reading sensor values of a Mobot module via the
Bluetooth wireless protocol. The functions are designed to be intuitive
and easy to use. Various functions are provided to control or obtain the speed,
direction, and position of the motors. The API includes C++ classes called
\texttt{CMobot} and \texttt{CMobotGroup} to facilitate control of 
single and multiple Mobots.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/joint_diagram_verbose.png}
\end{center}
\caption{\label{fig:joint_diagram_verbose.png} A schematic diagram of a Mobot module.}
\end{figure}

Figure \ref{fig:joint_diagram_verbose.png} shows a schematic diagram displaying the
locations and positive directions of the four joints of a Mobot module. The
joints 1 and 4 shown in the figure are fully rotational and have no joint limits.
Joints 2 and 3, however, can only move in the range -90 to +90 degrees.


\section{\label{sec:pairing}Configuring Mobots for Remote Control}
Mobot modules should be configured the first time they are used with 
a new computer. The process informs the computer which Mobots it
is allowed to connect to. The is also necessary for certain 
functions in the \texttt{CMobot} API, such as \texttt{connect()},
to determine which robots to connect to.

The configuration is performed through the Barobo RobotController
program. The remainder of the section contains step-by-step instructions
and screenshots showing how to configure your Mobots.

To start the provided Barobo Robot Control Program click on the icon labeled 
``RobotController'' on your desktop, as shown in \ref{fig:barobo_icon.png}. The 
control dialog as shown in Figure \ref{fig:shot1.png} should pop up.
\begin{figure}[H]
\begin{center}
\includegraphics[width=1in]{images/barobo_icon.png}
\end{center}
\caption{\label{fig:barobo_icon.png} The icon for the Barobo RobotController.}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot1.png}
\end{center}
\caption{\label{fig:shot1.png} The graphical user interface of the RobotController.}
\end{figure}

\subsection{Adding Bluetooth Addresses of Robots in RobotController.}
Click on the menu item ``Configure $\rightarrow$ Configure Robot Bluetooth'', as
shown in Figure \ref{fig:shot3.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot3.png}
\end{center}
\caption{\label{fig:shot3.png} Configuring robot bluetooth connection.}
\end{figure}

This should bring up a second dialog, titled ``Configure Robot Bluetooth'', as
shown in Figure \ref{fig:shot4.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot4.png}
\end{center}
\caption{\label{fig:shot4.png} The dialog window for bluetooth connection.}
\end{figure}

This dialog allows us to add robot bluetooth addresses to the list of currently
known robot bluetooth addresses. To add an address, first type in the address
in the text box on the top of the dialog, as shown in Figure \ref{fig:shot5.png}.
You can find the bluetooth address of each robot inside the battery compartment
of the robot on the same side as the power switch. 

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot5.png}
\end{center}
\caption{\label{fig:shot5.png} Adding the robot bluetooth address in the dialog window.}
\end{figure}

Next, click the ``Add'' button. The newly added address should appear in the 
list of known addresses, as shown in Figure \ref{fig:shot6.png}. In our case, we have added the 
address of one of our robots, which is \texttt{"00:06:66:43:0E:02"}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot6.png}
\end{center}
\caption{\label{fig:shot6.png} Displaying the added bluetooth address.}
\end{figure}

We use the same process to add our remaining two robots to the list,
with addresses \texttt{"00:06:66:43:0D:F2"} and 
\texttt{"00:06:66:47:23:9C"}. The dialog now appears as shown in
Figure \ref{fig:shot8.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot8.png}
\end{center}
\caption{\label{fig:shot8.png} Displaying bluetooth addresses for three robots.}
\end{figure}

The dialog also allows users to reorder the addresses listed. The
order the addresses are listed in affects the order in which the robots
are connected to using the \texttt{connect()} member function. 
The remote control dialog connects to the primary address located at the
top of the list by default. To reorder the list of addresses, simply
select the address to move and click on the ``Move Up'' or ``Move Down''
button to either move the address higher in the list or lower. For instance,
the result of clicking on the address \texttt{"00:06:66:43:0D:F2"} and clicking
the ``Move Up'' button is shown in Figure \ref{fig:shot10.png}.

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{images/shot10.png}
\end{center}
\caption{\label{fig:shot10.png} Modifying the order of bluetooth addresses with the ``Configure Robot Bluetooth'' dialog.}
\end{figure}

\subsection{Connecting and Disconnecting to Robots from the RobotController}
Once bluetooth addresses are added to the RobotController, you may connect to the 
first address by clicking on the ``Connect $\rightarrow$ Connect to Robot''
menu item. The connected robot may be disconnected by clicking on the 
``Connect $\rightarrow$ Disconnect from Robot'' menu item. Any connected robots are
automatically disconnected upon exiting the program. Note that in order to run a Ch
program that controls a robot, the robot should not currently be connected to any
other application, including the RobotController, other Ch programs, and other
programs on other computers.

\section{ The Robot Remote Control Program }
\begin{figure}[H]
\begin{center}
\includegraphics[width=4.5in]{images/shot1_populated.png}
\end{center}
\caption{\label{fig:shot1_populated.png} The graphical display of the RobotController
while connected to a robot.}
\end{figure}

Once a robot is connected to the RobotController, the joint angles and speeds
of the robot are displayed as shown in Figure \ref{fig:shot1_populated.png}.
The RobotController can then be
used to display
information about the Mobot's joint positions, and also control the
speeds and positions of the Mobot's joints. The interface is divided
up into six sections; three on the top half of the interface, and three on 
the bottom half. 

\subsection{The Mobot Diagram and ``Move To Zero'' Button}
The first section of the GUI located on the top left of the interface
displays a schematic diagram of the Mobot, displaying motor positions.
Underneath the diagram, there is a large button with the text 
``Move To Zero''. When clicked, this button will command the connected
Mobot to rotate all of its joints to a flat ``Zero'' position.

\subsection{Individual Joint Control}
The second section, located at the top-middle section of the interface,
is the ``Individual Joint Control'' section. These buttons command the
Mobot to move individual joints. When the up or down arrows are clicked,
the Mobot begins to move the corresponding joint in either the positive,
or negative direction. The joint will continue to move until the stop 
button, located between the up and down arrows, is clicked. 

If the joint encounters any obstacle that prevents it from moving, the 
joint will automatically disengage power to the joint. This may happen, 
example, if a body joint attempts to rotate beyond its limits,
or if it collides with the other corresponding body joint. 

\subsection{Rolling Control}
This section contains buttons for controlling the Mobot as a 
two wheeled mobile robot. The up and down buttons cause the Mobot to
roll forward or backward. The left and right buttons cause the Mobot 
to rotate towards the left, or towards the right. The stop button in the
middle causes the Mobot to stop where it is.

\subsection{Joint Speeds}
The ``Joint Speeds'' section, located at the bottom left of the interface,
displays and controls the current joint speeds of the Mobot.
The joint speeds are in units of degrees per second. To set a specific 
desired joint speed for a particular joint, the joint speed may be 
typed directly into the edit boxes below the sliders, and the ``Set''
button should be clicked.
 
\subsection{Joint Positions}
This section, located in the bottom-middle of the interface, is used to display
and control the positions of each of the four
joints of a Mobot. The joint positions are displayed in the numerical
text located above each vertical slider. The displayed joint positions are in
units of degrees.  
%There are two methods to control the joints using this interface.

The method of controlling the joints is by using the vertical sliders.
Each vertical slider's position represents a joint's angle. The sliders for the
two end joints vary from -180 degrees to 180 degrees, representing one complete
rotation. The angles for the two body joints vary from -90 to 90 degrees. When
the position of the slider is moved, the Mobot will move its joints to match the 
sliders. 

Underneath the sliders, there are four text entry boxes. The text boxes
accept specific angles for each joint which the user may type in. If 
the ``MoveTo'' button is clicked, each joint will move to their respective 
desired absolute positions. If any text entry is left blank, the corresponding joint will
not move. 

If the ``Move'' button is clicked, the program treats the angles entered by the
user as a relative amount to move. For instance, if the value ``360'' is entered
into the box for joint 1 and ``Move'' is clicked, the joint will rotate one full
rotation, no matter where the joint was when the motion began.
\begin{comment}
The second method for moving the joints is by entering the exact angles for the
joints. Below each of the four sliders lies a text entry box. Values in degrees
may be typed into each of the four entry boxes. When the button on the lower
right of the section labeled ``Move'' is clicked, the Mobot will move its joints
to match the values typed into the boxes. If no value is typed into a box, that 
joint will not move.
\end{comment}

\subsubsection{Joint Limits}
Joints 1 and 4 are fully rotational and have no joint limits. Joints 2 and 3, however, are 
limited to a range of -90 to +90 degrees.

\subsection{Motions}
This section, located on the bottom right of the interface, contains a set of
preprogrammed motions for the Mobot. To execute a preprogrammed motion, simply
click on the name of the motion you wish to execute, and then click the button
labeled ``Play''.

\subsection{Application Example for Learning Algebra}
\subsubsection{Problem Statement}
A robot has two 3.5 inch diameter wheels. It is moving at a constant velocity
by turning its wheels 45 degrees per second. 
\begin{enumerate}
\item How long will it take for the robot to rotate its wheels 2 full rotations? (720 degrees)
\item During that time, how far should the robot travel? Verify your results by measuring
the distance the real robot travels during the calculated time.
\end{enumerate}

\subsubsection{Problem Solution}
\begin{enumerate}
\item We are given that a robot is turning its wheels at a constant speed of 45 degrees per second, and 
needs to rotate the wheels 720 degrees. The amount of time this will take is
\begin{equation*}
\frac{720 ~\mathrm{degrees}}{45 ~\mathrm{degrees/second}} = 16 ~\mathrm{seconds}
\end{equation*}

\item The circumference of a circle can be determined with the equation
\begin{equation*}
c = 2 \pi r
\end{equation*} where $r$ is the radius of the circle. Since our robot will
turn its wheels two full rotations during the motion, it will travel 2 circumferences
in distance. Thus, the distance the robot should travel is
\begin{equation*}
d = 2 \times c = 2 \times (2 \pi r) = 4 \pi r
\end{equation*}
The radius of a circle is half of its diameter, which is $3.5 / 2 = 1.75$ inches, 
in our case. Plugging in our numbers, we have
\begin{equation*}
d = 4 \times \pi \times 1.75 = 21.99
\end{equation*}
Our robot should travel approximately 22 inches during the 16 second motion.
\end{enumerate}

To verify these results with a real robot the RobotController program may be used.
\begin{enumerate}
\item Affix two 3.5 inch diameter wheels to the faceplates.
\item Set the joint speeds for joints 1 and 4 to 45 degrees per second. This may
be done by typing "45" into the appropriate text boxes for joint 1 and 4 speeds at 
the bottom left of the RobotController and then clicking the "Set" button.
\item Type ``720'' into the text edit boxes below joints 1 and 4 in the joint
position section of the GUI.
\item Click the ``Move'' button. Joints 1 and 4 will turn 720 degrees, rolling
the robot forward. The motion may be timed with a stopwatch.
\end{enumerate}

\section{Getting Started with Programming the Mobot}
The RobotController can be used to control the Mobot for simple tasks and applications.
For more complicated applications, computer programs are better suited for controlling
the Mobot.
Mobot can be controlled using a C/C++ program through Ch, a C/C++ interpreter.
Ch Professional Edition or Ch Student Edition software is required to run the 
demo programs for controlling Mobot. Ch is available from SoftIntegration, Inc. at 
\texttt{http://www.softintegration.com}

Before the Ch program is executed, the Bluetooth addresses of the robots
need to be added using the RobotController as described in Section \ref{sec:pairing}.
If a robot is already connected to the RobotController, disconnect
from the robot before running the Ch program, or close the RobotController application.

To help the user become acquainted with the Mobot control programs, sample
programs will be presented in this section to illustrate the basics and minimum requirements of
a Mobot control program. The sample programs are located at 
\texttt{CHHOME/package/chmobot/demos}, where \texttt{CHHOME} is the 
Ch home directory, such as \texttt{C:$\backslash$Ch} for Windows. For Windows,
it is located at \texttt{C:$\backslash$Ch$\backslash$package$\backslash$chmobot$\backslash$demos} by default. 


The first demo presents a minimal program which connects to a Mobot and
moves joints 1 and 4.

\subsection{\texttt{start.ch}, A Basic Ch Mobot Program}
\subsubsection{\texttt{start.ch} Source Code}
\verbatiminput{../demos/chdemos/start.ch}

\subsubsection{\label{sec:democode}Demo Code for \texttt{start.ch} Explained}
The beginning of every Mobot control program will include header files. Each
header file imports functions used for a number of tasks, such as printing
data onto the screen or controlling the Mobot. The \texttt{mobot.h} header
file must be included in order to use the \texttt{CMobot} class and related
robotic control functions.

\begin{verbatim}
#include <mobot.h> // Required for Mobot control functions
\end{verbatim}

Next, we must initialize the C++ class used to control the Mobot. 

\begin{verbatim}
CMobot robot;
\end{verbatim}

This line
initializes a new variable named \texttt{robot} which represents the remote
Mobot module which we wish to control. This special variable is actually an
instance of the \texttt{CMobot} class, which contains its own set of
functions called ``methods'', ``member functions'', or simply ``functions''.

The next line,
\begin{verbatim}
robot.connect();
\end{verbatim}
will connect our new variable, \texttt{robot}, to a
Mobot that has been previously configured with the computer in the 
process described in Section \ref{sec:pairing}.

Note that there are two common methods to connect to a remote Mobot. 
The most common method, demonstrated in the previous line of code, is
used to connect to a Mobot that is already paired to the computer. It
is also possible to connect to Mobots which are not paired with the 
computer. This method is necessary for connecting to multiple
Mobots simultaneously, as only a single Mobot may be paired with the
computer at a time. The second method uses the function
\texttt{connectWithAddress()}, and its default usage is as such:
\begin{verbatim}
string_t address = "11:22:33:44:55:66";
int defaultChannel = 1;
robot.connectWithAddress(address, defaultChannel);
\end{verbatim}
The string \texttt{"11:22:33:44:55:66"} represents the Bluetooth address
of the Mobot, which must be known in advance. The channel number \texttt{1} 
represents the Bluetooth channel to connect to. Channel \texttt{1}
is the default channel Mobots listen on for incoming connections, but
may be set to other values depending on the type of robot. Detailed
documentation for each of the Mobot functions, such as 
\texttt{connect()} and \texttt{connectAddress()}, are presented in
Appendix \ref{sec:cmobot_api}.

\begin{figure}
  \centering
  \includegraphics[width=3in]{images/inchworm1.jpg}
  \caption{The robot in zero position}
  \label{fig:zeroposition}
\end{figure}

The next line,
\begin{verbatim}
robot.moveToZero();
\end{verbatim}
uses the \texttt{moveToZero()} member function. The
\texttt{moveToZero} function causes the Mobot to move all of its motors to the
zero position, as shown in Figure \ref{fig:zeroposition}.

The next line of code command joints 1 and 4 to rotate 360 degrees.
\begin{verbatim}
robot.move(360, 0, 0, 360);
\end{verbatim}
Note that the member function \texttt{move()} expects input angles
in degrees, so the angles in radians must be first be converted to degrees 
using the \texttt{rad2deg()} function. The \texttt{rad2deg()} function
takes an angle in radians as its argument and returns the angle in
degrees. The function is implemented in Ch with the code
\begin{verbatim}
#include <math.h> /* For M_PI */
double rad2deg(double radians)
{
    double degrees;
    degrees = radians * 180.0 / M_PI;
    return degrees;
}
\end{verbatim}

If desired, values in radians
may also be converted to degrees using the counterpart function,
\texttt{deg2rad()}.
Joints 1 and 4 are the faceplates
of the Mobot which are sometimes used to act as "wheels".

\subsection{\texttt{returnval.ch}, A Basic Ch Mobot Program Which Checks Return Values}
\subsubsection{Source Code}
\verbatiminput{../demos/chdemos/returnval.ch}

\subsubsection{\texttt{returnval.ch} Explained}
The first portion of the code, the lines
\begin{verbatim}
#include <mobot.h>
CMobot robot;
\end{verbatim}
set up our program for controlling robots as seen in previous demos. The next line,
\begin{verbatim}
double angle1, angle4;
\end{verbatim}
declares two variables that will be used to hold angle values later in the program.

The next
lines, which connect to the robot, appear as such:
\begin{verbatim}
if(robot.connect())
{
    printf("Failed to connect to the robot.\n");
    exit(0);
}
\end{verbatim}
This section connects to the remote robot as in previous examples, but also
does some error checking. The majority of the \texttt{CMobot} member functions
return an integer value indicating whether or not the function succeeded.
The \texttt{CMobot} member functions return 0 if they succeed, and -1
if any type of error has occurred. Errors may occur for any number of reasons,
including lost connections, mechanical failure, and electrical interference. 
The demos up to this point have ignored the return values of the 
\texttt{CMobot} member functions.

Next following lines,
\begin{verbatim}
/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();

/* Rotate each of the faceplates by 360 degrees */
angle1 = 360;
angle4 = 360;
robot.move(angle1, 0, 0, angle4);
/* Move the motors back to where they were */
angle1 = -360;
angle4 = -360;
robot.move(angle1, 0, 0, angle4);
\end{verbatim}
move the robot into its zero position, rotates its end plates by one full rotation, and then
rotates the end plates back to their original position. Unlike the previous demo, this 
demo uses variables to store the joint angle values. The variables are assigned 
values, and then used as the function arguments for the \texttt{move()} function.

\subsection{\texttt{getJointAngle.ch}, A Basic Ch Mobot Program Which Retrieves a Joint Angle}
\subsubsection{Source Code}
\verbatiminput{../demos/chdemos/getJointAngle.ch}

\subsubsection{\texttt{getJointAngle.ch} Explained}
The first portion of the program, 
\begin{verbatim}
#include <mobot.h>
CMobot robot;

/* Connect to a robot */
robot.connect();
\end{verbatim}
initialize the robot variable and connect to the remote robot, as shown in the
previous demo. Next, the line
\begin{verbatim}
double angle;
\end{verbatim}
initializes a new variable called \texttt{angle}, which will be used to store
the current angle of one of the robotic joints. The next line,
\begin{verbatim}
robot.getJointAngle(ROBOT_JOINT1, angle);
\end{verbatim}
retrieves the current angle of joint 1, which is one of the faceplates of the
robot. 
\texttt{ROBOT\_JOINT1} is an enumerated value
defined in the header file \texttt{mobot.h}. Detailed information
for all enumerated values defined in \texttt{mobot.h} can be found in 
Appendix \ref{sec:datatypes}.

Finally, the last line of the program,
\begin{verbatim}
printf("The current joint angle for joint 1 is %lf degrees.\n", angle);
\end{verbatim}
prints the value of the variable onto the screen. 


\section{Controlling the Speed of Mobot Joints}
\subsection{\texttt{setspeed.ch} Source Code}
\verbatiminput{../demos/chdemos/setspeed.ch}
\subsection{\texttt{setspeed.ch} Source Code Explanation}
The first several lines,
\begin{verbatim}
#include <mobot.h>
#include <math.h>

CMobot robot;

/* Connect to the paired Mobot */
robot.connect();

/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();
\end{verbatim}
initialize the program, connect to the robot, and move the robot into its zero position,
similar to the previous demos. The next three lines,
\begin{verbatim}
double speed, radius;
robot.getJointMaxSpeed(ROBOT_JOINT1, speed);
printf("The maximum speed is %lf degrees/s\n", speed);
\end{verbatim}
initializes the variables \texttt{speed} and \texttt{radius},
retrieves the maximum joint speed for the first joint using the member function,
\texttt{getJointMaxSpeed} and stores it in the variables named \texttt{speed}.
The value of the maximum speed is then printed onto the screen using the \texttt{printf()}
function.

The next two lines,
\begin{verbatim}
robot.setJointSpeed(ROBOT_JOINT1, 90);
robot.setJointSpeed(ROBOT_JOINT4, 90);
\end{verbatim}
set the joint speed settings for the two faceplate joints to 90 degrees per second.

The next lines, 
\begin{verbatim}
//robot.setJointSpeedRatio(ROBOT_JOINT1, 0.5);
//robot.setJointSpeedRatio(ROBOT_JOINT4, 0.5);

//robot.setJointSpeeds(90, 0, 0, 90);
\end{verbatim}
are two alternate ways of setting the joint speeds of the faceplate joints. 
The member function \texttt{setJointSpeedRatio()} sets the joint speeds as a ratio of the 
maximum speed. The function \texttt{setJointSpeeds()} is used to set all four
joint speeds simultaneously. Note though, that there is a slight difference between
using the \texttt{setJointSpeeds()} function as shown in this example compared to the
other methods. The other methods do not alter the joint speeds for joints 2 and 3, while
the \texttt{setJointSpeeds()} function used as shown in the example explicitely sets
the joint speeds of joints 2 and 3 to zero. 

The next two lines,
\begin{verbatim}
printf("Roll forward 360 degrees.\n");
robot.motionRollForward(360);
\end{verbatim}
print a message to the screen and rolls the robot forward by rotating the faceplates
360 degrees.

The next lines,
\begin{verbatim}
speed = (3.5/2) * M_PI / 2; // 2.75 inch/s 
radius = 3.5/2;             // radius is 1.75 
robot.setTwoWheelRobotSpeed(speed, radius);
\end{verbatim}
use the \texttt{setTwoWheelRobotSpeed()} function to set the faceplate joint
speeds for a robot acting as a two wheeled car. The
\texttt{setTwoWheelRobotSpeed()} function takes a desired speed
and the radius of the wheels as arguments and calculates the necessary
rotational speed of the faceplate wheels to achieve the desired speed. Note
that the units for the speed must match the units for the radius. For instance,
if the radius is provided in inches, the desired speed must be provided in 
inches per second. If the radius is provided in centimeters, the speed must
be provided in centimeters per second, and so on.

The following two lines,
\begin{verbatim}
printf("Move 360 degrees.\n");
robot.move(360, 0, 0, 360);
\end{verbatim}
rotate the faceplates forward at the necessary rate to achieve a forward speed of
2.75 inches per second.

Finally, the last two lines,
\begin{verbatim}
printf("Move continuously for 3 seconds.\n");
robot.moveContinuousTime(ROBOT_FORWARD, ROBOT_HOLD, ROBOT_HOLD, ROBOT_FORWARD, 3);
\end{verbatim}
roll the robot forward for three seconds.
The enumerated values \texttt{ROBOT\_FORWARD} and \texttt{ROBOT\_BACKWARD}
indicate the forward and backward directions for each motor to turn, respectively. 
\texttt{ROBOT\_NEUTRAL} indicates that the motor should not turn, but
should remain flexible and backdrivable. \texttt{ROBOT\_HOLD}
indicates that the joint will not turn, and that the joint will be 
forcefully held in place at its current position. More information regarding these
macros may be found in Section \ref{sec:robotJointState_t}. In the previous
line of code, joints 1 and 4 
move forward while joints 2 and 3 hold their current positions. The
last argument  of the function \texttt{moveContinuousTime()} specifies the
duration of time to move or hold the motors in seconds.


\section{\label{sec:preprogrammed_motions}Preprogrammed Motions}
The robot API contains functions for executing preprogrammed motions. The 
preprogrammed motions are motions which are commonly used for robot locomotion.
Following is a list of available functions and a brief description about
their effect on the robot.
\begin{itemize}
\item \texttt{motionArch()}: This function causes the robot to arch up for better 
clearance.
\item \texttt{motionInchwormLeft()}: This function causes the robot to perform
  the inchworm gait once, moving the robot towards its left.
\item \texttt{motionInchwormRight()}: This function causes the robot to perform
  the inchworm gait once, moving the robot towards its right.
\item \texttt{motionRollBackward()}: This function causes the robot to rotate
  its faceplates, using them as wheels to roll backward.
\item \texttt{motionRollForward()}: This function causes the robot to rotate
  its faceplates, using them as wheels to roll forward.
\item \texttt{motionSkinny()}: This function makes the robot assume a skinnier
rolling profile.
\item \texttt{motionStand()}: This function causes the robot to stand up onto a 
  faceplate, assuming the camera platform position.
\item \texttt{motionTumble()}: This function causes the robot to perform the
tumbling motion, flipping end over end.
\item \texttt{motionTurnLeft()}: This function uses the robot's faceplates as wheels, turning
  them in opposite directions in order to rotate the robot towards its left.
\item \texttt{motionTurnRight()}: This function uses the robot's faceplates as wheels, turning
  them in opposite directions in order to rotate the robot towards its right.
\item \texttt{motionUnstand()}: This function causes the robot to drop down from a standing position.
\end{itemize}

Note that all of the functions listed above are ``blocking'' functions, meaning
they will not return until the motion has completed. These functions also
have non-blocking equivalents which are discussed in Section
\ref{sec:blocking}.

\subsection{\texttt{inchworm.ch}: A Demo using the \texttt{motionInchwormLeft()}
Preprogrammed Motion}
\subsubsection{\texttt{inchworm.ch} Source Code}
\verbatiminput{../demos/chdemos/inchworm.ch}
\subsubsection{\texttt{inchworm.ch} Explained}
First, the header file \texttt{mobot.h} is included. This header file
is required before usage of the \texttt{CMobot} class and its associated
member functions can be used. Next, we create a variable to reperesent our
robot and connect to the robot with the following lines.
\begin{verbatim}
CMobot robot;

/* Connect to the paired Mobot */
robot.connect();
\end{verbatim}

Next, we set the motor speeds to 50\% speed with the following lines.
\begin{verbatim}
robot.setJointSpeedRatio(ROBOT_JOINT2, 0.50);
robot.setJointSpeedRatio(ROBOT_JOINT3, 0.50);
\end{verbatim}

We then move the robot to its zero position in preparation for the 
inchworm gait.
\begin{verbatim}
robot.moveToZero();
\end{verbatim}

Finally, we perform the inchworm gait four times. The argument for the
function \texttt{motionInchwormLeft()} reperesents the number of times
the gait should be performed.
\begin{verbatim}
robot.motionInchwormLeft(4);
\end{verbatim}


\subsection{\texttt{stand.ch}: A Demo Using the \texttt{motionStand()} Preprogrammed
Motion}
This demo is a simple demonstration of the \texttt{motionStand()} member function.
\subsubsection{\texttt{stand.ch} Source Code}
\verbatiminput{../demos/chdemos/stand.ch}
\subsubsection{\texttt{stand.ch} Explained}
After the initialization and 
connection as seen in the previous demo, it executes the following line of
code:
\begin{verbatim}
robot.motionStand();
\end{verbatim}
This line of code causes the Mobot to perform a sequence of motions causing it to
stand up on a faceplate. After the robot has stood up, the next line of code,
\begin{verbatim}
sleep(3); // Stand still for three seconds
\end{verbatim}
pauses the program for three seconds, causing the robot to remain still for three
seconds. If you would like to pause a program for less than one second, use the 
function \texttt{msleep(msecs)} to pause for ``msecs'' milliseconds.

After the pause is over, the line
\begin{verbatim}
robot.move(2*360, 0, 0, 2*360);
\end{verbatim}
turns both faceplates of the robot two full rotations, making the robot spin in place
while standing. Finally, the line
\begin{verbatim}
robot.motionUnstand();
\end{verbatim}
causes the robot to drop back down into a flat position.

\subsection{\texttt{tumble.ch}: A Demo Using the \texttt{motionTumble()} Preprogrammed
Motion}
\subsubsection{\texttt{tumble.ch} Source Code}
\verbatiminput{../demos/chdemos/tumble.ch}
\subsubsection{\texttt{tumble.ch} Explained}
The first portion of the program,
\begin{verbatim}
/* Filename: tumble.ch 
 * Tumbling robot */
#include <mobot.h>
CMobot robot;

/* Connect to the paired Mobot */
robot.connect()
/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();
\end{verbatim}
initialize the proper variables, connect to the remote robot, and make it move
to a flat zero position, similar to previous demos.

Next, we make the robot perform the tumbling motion with the following line:
\begin{verbatim}
robot.motionTumble(2);
\end{verbatim}
The argument, ``2'', indicates that the tumbling motion should be performed
two times.

\subsection{\texttt{motion.ch}: A Demo Using Multiple Preprogrammed Motions}
\subsubsection{\texttt{motion.ch} Source Code}
\verbatiminput{../demos/chdemos/motion.ch}
\subsubsection{\texttt{motion.ch} Explained}
The first portion of the program initializes and connects to the
remote robot similar to the previous demos.

The next portion of code executes a number of different pregrammed motions
to demonstrate the motion capabilities of the robot. First, the ``Arch'' motion
is demonstrated by the following line of code:
\begin{verbatim}
robot.motionArch(15);
\end{verbatim}
The parameter given to the function, ``15'' in this case, is the angle in degrees 
that the body joints should form in relation to each other. 

The next couple lines of code,
\begin{verbatim}
robot.motionInchwormLeft(4);
robot.motionInchwormRight(4);
\end{verbatim}
make the robot inchworm to the left four times, and then inchworm to the right
four times. 

Next, the lines
\begin{verbatim}
robot.motionRollBackward(360);
robot.motionRollForward(360);
robot.motionTurnLeft(360);
robot.motionTurnRight(360);
\end{verbatim}
make the robot roll backward, forward, and then turn left, and turn right
sequentially. For each of these functions, the parameter is the angle in degrees
to turn the faceplates. For instance, the line rolls the robot backward
using its faceplates as wheels by rotating the faceplates 360 degrees.

Next, the robot stands up by executing the line
\begin{verbatim}
robot.motionStand();
\end{verbatim}

While the robot is standing, the line
\begin{verbatim}
robot.move(360, 0, 0, 360);
\end{verbatim}
rotates both faceplates one complete rotation. This causes the robot to spin around 
in a circle, since it is currently standing on one of its faceplates.

Next, we lay the robot back down into a prone position with the following line
of code:
\begin{verbatim}
robot.motionUnstand();
\end{verbatim}

Finally, we perform the tumbling motion. 
\begin{verbatim}
robot.motionTumble(2);
\end{verbatim}
The tumbling motion is a movement in which
the robot stands up and then flips, end over end. The argument provided to the
function, ``2'' in this case, is the number of times to perform the motion.

\section{Detailed Examples of Preprogrammed Motions and Writing Customized Motions}
In the previous sections, preprogrammed motions have been demonstrated. In this section,
the inner workings of the preprogrammed motions will be discussed, as well as various
methods of designing and creating custom motions. Some more complex motions, such as 
"motionTumble()" and "motionUnstand()" will be discussed in Section \ref{sec:blocking}.
\subsection{Inchworm Gait Demo}
The next demo will illustrate how a simple gait known as the ``Inchworm'' gait 
can be implemented.

\subsubsection{\texttt{inchworm2.ch} Source Code}
\verbatiminput{../demos/chdemos/inchworm2.ch}

\subsubsection{Demo Code for \texttt{inchworm2.ch} Explained}
The first portion of the code is identical to the previous demo, and performs
the same function of declaring a Mobot variable and connecting to a 
paired Mobot.
\begin{verbatim}
#include <mobot.h>
CMobot robot;

/* Connect to the paired Mobot */
robot.connect();
\end{verbatim}

The next lines of code set the joint speeds for the two body joints, joints 
2 and 3, to 50\% speed. They are set to fifty percent speed in order to 
slow the motion down in order to minimize slippage.

\begin{verbatim}
/* Set robot motors to speed of 0.50 */
robot.setJointSpeedRatio(ROBOT_JOINT2, 0.50);
robot.setJointSpeedRatio(ROBOT_JOINT3, 0.50);
\end{verbatim}

Next, we move the robot into a flat ``zero'' position, as shown in Figure \ref{fig:inchworm1}.

\begin{verbatim}
/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();
\end{verbatim}

\begin{figure}
  \centering
  \subfloat[Zero Position]{\label{fig:inchworm1}\includegraphics[width=1in]{images/inchworm1.jpg}}
  \subfloat[Move joint 2]{\label{fig:inchworm2}\includegraphics[width=1in]{images/inchworm2.jpg}}
  \subfloat[Move joint 3]{\label{fig:inchworm3}\includegraphics[width=1in]{images/inchworm4.jpg}}
  \subfloat[Move joint 2]{\label{fig:inchworm4}\includegraphics[width=1in]{images/inchworm3.jpg}}
  \subfloat[Move joint 3 back to zero position]{\label{fig:inchworm5}\includegraphics[width=1in]{images/inchworm1.jpg}}
  \caption{The inchworm motion}
  \label{fig:inchworm}
\end{figure}

Finally, we perform the actual inchworm motion. The inchworm motion is a gait defined
by a sequence of motions performed by the body joints. The motions are as such:
\begin{enumerate}
\item The first body joint, referred to as joint A, rotates towards the ground.
This drags the Mobot towards the direction of joint A. (Figure \ref{fig:inchworm2})
\item The other body joint, joint B, rotates towards the ground. Since the center
of gravity is currently positioned over joint A, this causes the trailing body 
joint to slide toward joint A. (Figure \ref{fig:inchworm3})
\item Joint A moves back to a flat position. (Figure \ref{fig:inchworm4})
\item Joint B moves back to a flat position. (Figure \ref{fig:inchworm5})
\item Repeat, if desired.
\end{enumerate}
The direction of travel depends on the selection of the initial body joint. In
the following code example, joint 2 is chosen as the initial body joint to move.
In this case, the Mobot will traverse towards joint 2. The entire motion is
encapsulated in a ``for'' loop which executes the entire motion four times.
\begin{verbatim}
/* Do the inchworm gait four times */
int i, num = 4;
double angle2 = -45;
double angle3 = 45;
for(i = 0; i < num; i++) {
    robot.moveJointTo(ROBOT_JOINT2, angle2); /* Move joint 2 */
    robot.moveJointTo(ROBOT_JOINT3, angle3); /* Move joint 3 */
    robot.moveJointTo(ROBOT_JOINT2, 0);      /* Move joint 2 */
    robot.moveJointTo(ROBOT_JOINT3, 0);      /* Move joint 3 bace to zero position*/
}
\end{verbatim}
The values of the variables \texttt{angle2} and \texttt{angle3} may also be modified
to produce different variations of the inchworm gait to accomodate different terrain
textures and ground surfaces.

\subsection{Standing Demo}
\subsubsection{\texttt{stand2.ch} Source Code}
\verbatiminput{../demos/chdemos/stand2.ch}
\subsubsection{\texttt{stand2.ch} Explained}
The first portion of the program performs the necessary setup and connecting,
similar to the previous demos. Similar to the previous inchworm demo, the
motor speeds are set to a speed of 90 degrees per second, and the function \texttt{moveToZero()} is
called to put the robot into a flat position. Next, the following lines
are executed:
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT2, -85);
robot.moveJointTo(ROBOT_JOINT3, 70);
\end{verbatim}
These movement commands cause the Mobot to curl up into a fetal position with
both of its faceplates facing toward the ground. The next line, 

\begin{verbatim}
sleep(1);
\end{verbatim}
causes the program to pause for one second before continuing. This allows the
robot to settle down, in case it was still in motion from the last movement.

Next, the Mobot rotates one 
of the faceplates by 45 degrees. 
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT1, 45);
\end{verbatim}
This endplate will eventually become the ``foot'' of the standing Mobot. Next,
the Mobot lifts itself into a standing position, balancing on its endplate.
\begin{verbatim}
robot.moveJointTo(ROBOT_JOINT2, 20);
\end{verbatim}
Note that the previous joint angle for Joint 2, a body joint, was -85 degrees. 
This motion causes joint 2 to rotate all the way to a 20 degree position, which
lift up the body of the Mobot such that the Mobot is balancing on faceplate joint 1.

Finally, we rotate joint 1, the foot joint, for three seconds which causes the
entire Mobot to rotate in place. The speed is first set to 45 degrees per second to make the
rotation a slow rotation. Next, the \texttt{moveContinuousTime} member function
is used to continuously rotate a joint for a desired amount of time.
\begin{verbatim}
robot.setJointSpeed(ROBOT_JOINT1, 45);
robot.moveContinuousTime(ROBOT_FORWARD, ROBOT_HOLD, ROBOT_HOLD, ROBOT_HOLD, 3);
\end{verbatim}

\section{\label{sec:blocking}Blocking and Non-Blocking Functions}
All of the Mobot movement functions may be designated as either ``blocking'' 
functions or ``non-blocking'' functions. A blocking function is a function which
does not return while operations are being performed. All standard C functions,
such as \texttt{printf()}, are blocking functions. The
\texttt{moveWait()} function is a blocking function. When called, the function
will hang, or ``block'', until all the joints have stopped moving. After all
joints have stopped moving, the \texttt{moveWait()} function will return, and 
the rest of the program will execute.

Furthermore, some functions have both a blocking version and a non-blocking
version. For these functions, the suffix \texttt{NB} denotes that the function
is non-blocking. For instance, the function \texttt{motionStand()} is blocking,
meaning the function will not return until the motion is completed, whereas
the function \texttt{motionStandNB()} is non-blocking, meaning the function
returns immediately and the robot performs the ``standing'' motion
asynchronously.

The function \texttt{moveNB()} is an example of a non-blocking function. When
the \texttt{moveNB()} function is called, the function immediately returns 
as the joints begin moving. Any lines of code following the call to 
\texttt{moveNB()} will be executed even if the current motion is still in
progress. 

Demos for the non-blocking functions are located in the next section of
this document.

\subsection{List of Blocking Movement Functions}
\begin{itemize}
\item \texttt{move()}
\item \texttt{moveContinuousTime()}
\item \texttt{moveJoint()}
\item \texttt{moveJointTo()}
\item \texttt{moveJointWait()}
\item \texttt{moveTo()}
\item \texttt{moveToZero()}
\item \texttt{moveWait()}
\item \texttt{motionArch()}
\item \texttt{motionInchwormLeft()}
\item \texttt{motionInchwormRight()}
\item \texttt{motionRollBackward()}
\item \texttt{motionRollForward()}
\item \texttt{motionSkinny()}
\item \texttt{motionStand()}
\item \texttt{motionTumble()}
\item \texttt{motionTurnLeft()}
\item \texttt{motionTurnRight()}
\item \texttt{motionUnstand()}
\end{itemize}

\subsection{List of Non-Blocking Movement Functions}
\begin{itemize}
\item \texttt{moveNB()}
\item \texttt{moveContinuousNB()}
\item \texttt{moveJointNB()}
\item \texttt{moveJointToNB()}
\item \texttt{moveToNB()}
\item \texttt{moveToZeroNB()}
\item \texttt{motionArchNB()}
\item \texttt{motionInchwormLeftNB()}
\item \texttt{motionInchwormRightNB()}
\item \texttt{motionRollBackwardNB()}
\item \texttt{motionRollForwardNB()}
\item \texttt{motionSkinnyNB()}
\item \texttt{motionStandNB()}
\item \texttt{motionTumbleNB()}
\item \texttt{motionTurnLeftNB()}
\item \texttt{motionTurnRightNB()}
\item \texttt{motionUnstandNB()}
\end{itemize}

\subsection{Blocking and Non-Blocking Demo Programs}
\subsubsection{\texttt{nonblock.ch} Source Code}
\verbatiminput{../demos/chdemos/nonblock.ch}
\subsubsection{\texttt{nonblock.ch} Source Code Explanation}
This demo gives an example of how non blocking functions operate. 
After the initial setup and initialization similar to the previous
demos, the following line is executed:
\begin{verbatim}
robot.moveNB(720, 0, 0, 720); // Non-Blocking version
\end{verbatim}
The function \texttt{moveNB()} is a non-blocking function, which means
that the program will continue executing even before the movement
has completed. The next lines of code appear as such:
\begin{verbatim}
while(robot.isMoving()) {
    printf("robot is moving ...\n");
}
\end{verbatim}
The previous lines of code basically loops as long as the \texttt{robot.isMoving()} function
is returning true. In other words, in plain english, as long as the robot is moving,
the program will print the message ``robot is moving...''. As soon as the robot completes
its motion, the loop will break and the message ``move finished!'' is printed.

Alternatively, there is a commented line of code that appears in the program, which
appears as
\begin{verbatim}
robot.move(720, 0, 0, 720); // Non-Blocking version
\end{verbatim}
If the \texttt{moveNB()} function is replaced with the \texttt{move()} function in this program,
the message ``robot is moving...'' is never printed to the screen. This is due to the
fact that \texttt{move()} is a blocking function, and by the time the program continues past
the \texttt{move()} statement, the robot has already stopped moving.

\subsubsection{\texttt{nonblock2.ch} Source Code}
\verbatiminput{../demos/chdemos/nonblock2.ch}
\subsubsection{\texttt{nonblock2.ch} Source Code Explanation}
The first block of the source code initialized and sets up the remote robot 
similar to previous demos. The last two lines in the program appear like so:
\begin{verbatim}
robot.moveJointNB(ROBOT_JOINT1, 360); // Non-Blocking version
robot.moveJoint(ROBOT_JOINT4, 360);
\end{verbatim}
The first line turns joint 1 for 360 degrees. However, since it is moved with a non-blocking function,
the program immediately continues to the next line. The second line turns joint 4 for
360 degrees. Because computer programs execute so fast compared to the physical
motion of the robots, this program effectively begins rotating joints 1 and 4 
simultaneously. Since the function \texttt{moveJoint()} is a blocking function,
the program will not execute beyond that point until joint 4 has finished moving.

\subsubsection{\texttt{nonblock3.ch} Source Code}
\verbatiminput{../demos/chdemos/nonblock3.ch}
\subsubsection{\texttt{nonblock3.ch} Source Code Explanation}
The first section of code initializes the necessary variables to control remote
robots as seen in previous demos. Next, we print a message on the screen and 
roll the robot forward with the following two lines of code.
\begin{verbatim}
printf("Rolling 360 degrees.\n");
robot.motionRollForward(360);
\end{verbatim}
Next, we make two calls to non-blocking functions.
\begin{verbatim}
robot.motionArchNB(15);
robot.motionRollForwardNB(360);
\end{verbatim}
The first call is to the function \texttt{motionArchNB()}, which arches the robot
up by moving joints 2 and 3. Since it is a non-blocking function, the program
immediately continues on even before the arching motion as finished. The
next call rolls the robot forward by rotating joints 1 and 4. In effect, these
two lines cause the robot to roll forward and arch simultaneously. It is important
to note that this compound motion works because the Arch motion only moves 
joints 2 and 3 while the rolling motions only move joints 1 and 4, so there are
no conflicting motor commands.

In order to wait for all motions to finish, the last line of the program is
\begin{verbatim}
robot.motionWait();
\end{verbatim}
The \texttt{motionWait()} function will wait until all robot motions are finished.

Note that
if a program contains non-blocking functions, it is typically necessary to 
call a waiting function such as \texttt{moveWait()} or \texttt{motionWait()}
before the program terminates. If a waiting function is not called, the program
may terminate before the motion has been completed, which may halt the robot
in the middle of one of its motions.

\subsection{Preprogrammed Motion Demos with Non-Blocking Functions}
\subsubsection{\texttt{unstand2.ch} Source Code}
\verbatiminput{../demos/chdemos/unstand2.ch}
\subsubsection{\texttt{unstand2.ch} Source Code Explanation}
The first block of code,
\begin{verbatim}
/* Filename: unstand.ch 
 * Drop the robot down from a standing position. */
#include <mobot.h>
CMobot robot;

/* Connect to the paired Mobot */
robot.connect();
\end{verbatim}
initialize the program and connect to the remote robot. Next, a series of
non-blocking movements are performed:
\begin{verbatim}
robot.moveJointToNB(ROBOT_JOINT2, -85);
robot.moveJointToNB(ROBOT_JOINT3, 45);
\end{verbatim}
Because both of these function calls are non-blocking, this function will
effectively move joints 2 and 3 simultaneously. Since these are both
non-blocking functions, a call to \texttt{moveWait()} is necessary to
wait for the robot to complete its motions, as done in the next line:
\begin{verbatim}
robot.moveWait();
\end{verbatim}

Finally, we move the robot into a flat zero position with the following line:
\begin{verbatim}
robot.moveToZero();
\end{verbatim}

\subsubsection{\texttt{tumble2.ch} Source Code}
\verbatiminput{../demos/chdemos/tumble2.ch}
\subsubsection{\texttt{tumble2.ch} Source Code Explanation}
The first lines of the program,
\begin{verbatim}
#include <mobot.h>
CMobot robot;

/* Connect to the paired Mobot */
robot.connect();

/* Set the robot to "home" position, where all joint angles are 0 degrees. */
robot.moveToZero();
\end{verbatim}
initialize the proper variables and connections as seen in previous demos.

Next, we begin the tumbling motion. We consider each tumbling motion to be the 
robot flipping over twice. The reason the robot flips twice per tumble is so that
when the tumbling motion is done, the robot ends right side up. 
A for loop is used to to tumble ``num'' times, as shown in the following code:
\begin{verbatim}
int i, num = 2;
for(i = 0; i < num; i++) {
\end{verbatim}
These lines create two new variables, ``i'' and ``num'', which are the loop
counter, and the number of times to tumble, respectively. 

Inside the loop, two tumbling motions are performed. The first tumbling
motion appears as such:
\begin{verbatim}
    /* First lift and tumble */
    robot.moveJointTo(ROBOT_JOINT2, -85);
    robot.moveJointTo(ROBOT_JOINT3, 80);
    robot.moveJointTo(ROBOT_JOINT2, 0);
    robot.moveJointTo(ROBOT_JOINT3, 0);
    robot.moveJointTo(ROBOT_JOINT2, 80);
    robot.moveJointTo(ROBOT_JOINT2, 45);
\end{verbatim}
This movement is similar to the \texttt{motionStand()} motion, except that the
robot flips all the way over after standing up. After this motion is done,
the robot is balancing on joint 4. Next, we flip again so that the robot
is balancing on joint 1.
\begin{verbatim}
    /* Second lift and tumble */
    robot.moveJointTo(ROBOT_JOINT3, -85);
    robot.moveJointTo(ROBOT_JOINT2, 80);
    robot.moveJointTo(ROBOT_JOINT3, 0);
    robot.moveJointTo(ROBOT_JOINT2, 0);
    robot.moveJointTo(ROBOT_JOINT3, 80);
    if(i != (num-1)) { /* Do not perform this motion on the last tumble */
        robot.moveJointTo(ROBOT_JOINT3, 45);
    }
}
\end{verbatim}
The \texttt{if} statement prevents the last motion from being executed
when the robot is on its last tumble. This is because the last motion in the
loop is a prepatory motion for the next tumble, which is not needed if the
robot is currently performing its last tumble. 

The entire motion, consisting of two flips, are performed ``num'' times. After
the loop is completed, the robot is made to fall back down into a prone
positions with the following lines of code:
\begin{verbatim}
/* Unstand the robot */
robot.moveJointToNB(ROBOT_JOINT2, 0);
robot.moveJointToNB(ROBOT_JOINT3, 0);
robot.moveWait();
robot.moveToZero();
\end{verbatim}


\section{Controlling Multiple Modules}
The Mobot control software is designed to be able to control multiple modules
simultaneously. There are some important differences in the program 
which enable the control of multiple modules. A small demo program which
controls two modules simultaneously will first be presented, followed by
a detailed explanation of the program elements.

\subsection{\texttt{twoModules.ch} Source Code}
\verbatiminput{../demos/chdemos/twoModules.ch}

\subsection{Demo Explanation}
The first two lines of interest appear as such:
\begin{verbatim}
  CMobot robot1;
  CMobot robot2;
\end{verbatim}
These two lines declare two separate variables which will represent the
two separate Mobot modules. Next, we need to connect each variable to
a physically separate Mobot. This is done with the following lines.
\begin{verbatim}
  robot1.connect();
  robot2.connect();
\end{verbatim}
These two lines connect the robots to the first two addresses
of the known robot addresses. The list of the computer's known
robot addresses may be configured in the process detailed in Section
\ref{sec:pairing} on page \pageref{sec:pairing}. For each separate
control program, the first call to the \texttt{connect()} member
function will connect to the first robot listed in the configuration
file. Each successive call to the \texttt{connect()} function will
connect to successive robots listed in the configuration file. 
The order in which they are connected may be modified using the
``Configure Robot Bluetooth'' dialog, as discussed in Section
\ref{sec:pairing}.

\begin{verbatim}
  robot1.moveToZeroNB();
  robot2.moveToZeroNB();
\end{verbatim}
These two lines command the two robots to move to their zero positions.
Note that these functions are non-blocking. This means that the
\texttt{moveToZeroNB()} function will return immediately, and will not
wait for the first robot to finish completing the motion before 
commanding the second robot to begin. In a normal program, this effectively
causes both robots to move to their zero positions simultaneously.

\begin{verbatim}
  robot1.moveWait();
  robot2.moveWait();
\end{verbatim}
Since the \texttt{moveToZeroNB()} functions are non-blocking, we would like
the program to wait until the motions are complete before continuing. By
calling \texttt{moveWait()} on both of the robots, we can be assured that
the robots have finished moving before the program continues.

\begin{verbatim}
  robot1.motionStandNB();
  robot2.motionInchwormLeftNB(4);
\end{verbatim}
Similar to the calls to \texttt{moveToZeroNB()}, this block of code instructs 
the first Mobot to stand and the second Mobot to perform the inchworm motion four times.
Note that we call the non-blocking versions of the
functions, \texttt{motionStandNB()} and \texttt{motionInchwormLeftNB()}. Since these functions are
non-blocking, both robots will effectively perform the motions simultaneously. 

When the first robot finishes standing, we want it to spin around on its faceplate
while the second robot is still inchworming. We can accomplish this by first
waiting for the standing motion to finish, and then moving the faceplate joints
of the first robot, as in the following lines of code.
\begin{verbatim}
  robot1.motionWait();
  robot1.moveNB(360, 0, 0, 360);
\end{verbatim}

Before we continue with the program, we wish to ensure that motion has stopped on both
robots. Since the the last command sent to \texttt{robot1} was a \texttt{moveNB()}
command, we use the \texttt{moveWait()} function to wait for that movement to finish.
Similarly, the last command sent to \texttt{robot2} was a motion command, and so we
use \texttt{motionWait()} to wait for the motion to finish. The two lines of code
are seen in the program as follows:
\begin{verbatim}
  robot1.moveWait();
  robot2.motionWait();
\end{verbatim}

Finally, the following lines,
\begin{verbatim}
robot1.motionUnstandNB();
robot2.motionInchwormRightNB(4);
robot1.motionWait();
robot1.motionTumble(1);
robot2.motionWait();
\end{verbatim}
make the first robot come back down from its standing position and the second robot
inchworm to the right four times simultaneously. Note that the function 
\texttt{motionWait()} is used to wait for motions, which are compound
movements, to finish. This is similar to how
the function \texttt{moveWait()} is used to wait for individual movements
to finish. After \texttt{robot1} finishes unstanding, it will begin 
a tumbling motion. Since the tumbling motion function is called before the call
to \texttt{robot2.motionWait()}, \texttt{robot1} will begin tumbling even if
\texttt{robot2} has finished its previous motion, which was inchworming 4 times.

\subsection{Controlling Multiple Connected Modules}
\subsubsection{\texttt{lift.ch}, Lifting Demo}
\verbatiminput{../demos/chdemos/lift.ch}
\subsubsection{\texttt{lift.ch} Source Code Explanation}
This demo is designed to lift two connected modules up into
a two-legged standing configuration. The robots are connected such that the fourth
joint of robot one is connected to the first joint of robot two. The two connect robots
act as one long robot.

The first portion of the program initialize two variables called \texttt{robot1} 
and \texttt{robot2}, which will be used to control the two connected modules.
Once the robots are initialized, they are both moved into a flat zero position.

The next lines,
\begin{verbatim}
/* First lift */
robot1.moveNB(0, -90,  0, 0);
robot2.moveNB(0, 0, 90, 0);
robot1.moveWait();
robot2.moveWait();
\end{verbatim}
rotate the joints on either end of the compound robot to perform the 
first portion of the lift, as shown in Figure \ref{fig:lift1}. The motion is performed as two non-blocking
calls to \texttt{moveNB()} and then waiting for both movements to finish.

\begin{figure}
  \centering
  \subfloat[First lift]{\label{fig:lift1}\includegraphics[width=2in]{images/lift1_v2.jpg}}
  \subfloat[Second lift]{\label{fig:lift2}\includegraphics[width=2in]{images/lift2_v2.jpg}}
  \caption{Lifting motion with two connected modules}
  \label{fig:lift}
\end{figure}

The next lines rotate the inner joints of the compound robot to lift the robot
one step higher, as shown is Figure \ref{fig:lift2}.
\begin{verbatim}
/* Second lift */
robot1.moveToNB(0, 0, 90,  0);
robot2.moveToNB(0,  -90, 0, 0);
robot1.moveWait();
robot2.moveWait();
\end{verbatim}
Again, these lines perform two calls to the non-blocking function
\texttt{moveNB()} and then wait for the movements to finish.

Finally, we move both robots back to their zero positions, which drops 
the compound robot back onto the ground.
\begin{verbatim}
robot1.moveToZeroNB();
robot2.moveToZeroNB();
robot1.moveWait();
robot2.moveWait();
\end{verbatim}

\section{Commanding Multiple Robots to Perform Identical Tasks}
The class called \texttt{CMobotGroup} can be used
to control multiple modules simultaneously. The \texttt{CMobotGroup} represents
a group of robots. Any command that is given to the group of modules is 
duplicated to each member of the group.

The majority of the movement functions available in the \texttt{CMobot} class
are also available in the \texttt{CMobotGroup} class. 
The detailed information for each member function are presented in 
Appendix \ref{sec:cmobotgroup_api}.
 Following
is a complete listing of the available member functions in the \texttt{CMobotGroup}
class.

\vspace{8pt}
\noindent
\input{cmobotgroup_table.tex}

\noindent
\input{cmobotgroup_motions_table.tex}

\subsection{Demo program \texttt{group.ch}}
\subsubsection{Source Code}
\verbatiminput{../demos/chdemos/group.ch}

\subsubsection{Demo Explanation}
The first lines of interest appear as such:

\begin{verbatim}
CMobot robot1;
CMobot robot2;
CMobotGroup group;
\end{verbatim}

These lines declare two robot variables, and one variable which
will represent a group of robots. Next, we connect the robot
variables to their physical counterparts.

\begin{verbatim}
robot1.connect();
robot2.connect();
\end{verbatim}

Once they are connected, we wish to add both of these robots to our robot group,
which we have named \texttt{group}.

\begin{verbatim}
group.addRobot(robot1);
group.addRobot(robot2);
\end{verbatim}

Finally, we wish for all of the robots in our robot group, namely
\texttt{robot1} and \texttt{robot2}, to peform an inchworm motion four times, followed
by a standing motion. This is done with the following lines:

\begin{verbatim}
group.motionInchwormLeft(4);  /* Both robots inchworm left 4 times */
group.motionStand();          /* Both robots stand */
\end{verbatim}

After the robots stand up, the line
\begin{verbatim}
group.move(360, 0, 0, 360);   /* Joints 1 and 4 rotate 360 degrees */
\end{verbatim}
makes the robots perform a 360 degree rotation on their faceplates
while standing.

The next line, 
\begin{verbatim}
sleep(3);                     /* Robots stand still for 3 seconds */
\end{verbatim}
makes the robots stand still for three seconds. After standing
still for three seconds, the line
\begin{verbatim}
group.motionUnstand();        /* Robots get back down from standing */
\end{verbatim}
makes both robots move back down from a standing position into a prone
position.

\subsection{Demo Program \texttt{groups.ch}}
\subsubsection{\texttt{groups.ch} Source Code}
\verbatiminput{../demos/chdemos/groups.ch}
\subsubsection{Demo Explanation}
The program begins by including the \texttt{mobot.h} header file
and declaring a number of robot variables and robot group variables.
\begin{verbatim}
#include <mobot.h>
CMobot robot1;
CMobot robot2;
CMobot robot3;
CMobot robot4;
CMobotGroup groupA;
CMobotGroup groupB;
CMobotGroup groupC;
CMobotGroup groupD;
\end{verbatim}

Next, we connect our four robot variables to the first four robots 
configured in our RobotController.
\begin{verbatim}
robot1.connect();
robot2.connect();
robot3.connect();
robot4.connect();
\end{verbatim}

Now we begin adding our robots to their groups. We will have four different groups, and each robot
will belong to more than one group. They will be organized as such:
\begin{itemize}
\item Group A: robot1, robot2, robot3, robot4
\item Group B: robot1, robot2
\item Group C: robot3, robot4
\item Group D: robot1, robot2, robot3
\end{itemize}
The following code divides the robots up into our groups.
\begin{verbatim}
/* Group A */
groupA.addRobot(robot1);
groupA.addRobot(robot2);
groupA.addRobot(robot3);
groupA.addRobot(robot4);

/* Group B */
groupB.addRobot(robot1);
groupB.addRobot(robot2);

/* Group C */
groupC.addRobot(robot3);
groupC.addRobot(robot4);

/* Group D */
groupD.addRobot(robot1);
groupD.addRobot(robot2);
groupD.addRobot(robot3);
\end{verbatim}

Now we perform some group oriented motions. First, we will have group B roll forward and group C
roll backward simultaneously. This is done with calls to non-blocking functions and using the
function \texttt{motionWait()} to wait for the non-blocking functions to finish.
\begin{verbatim}
/* Make group B roll forward and group C roll backward at the same time */
groupB.motionRollForwardNB(360);
groupC.motionRollBackwardNB(360);
groupB.motionWait();
groupC.motionWait();
\end{verbatim}

Next, we make all the robots, which are members of the group \texttt{groupA}, 
stand up.
\begin{verbatim}
/* Make all the robot stand up */
groupA.motionStand();
\end{verbatim}

While the robots are standing, we want group B to spin counter-clockwise, and group
C to spin clockwise. To do this, we use the non-blocking function \texttt{moveNB()}
and then wait for the movements to finish with \texttt{moveWait()}.
\begin{verbatim}
/* Make robots 1 and 2 (Group B) rotate counter-clockwise and robots 3 and 4
 * (Group C) rotate clockwise. */
groupB.moveNB(360, 0, 0, 360);
groupC.moveNB(-360, 0, 0, -360);
groupB.moveWait();
groupC.moveWait();
\end{verbatim}

Finally, we want robots 1, 2, and 3 to spin while robot 4 unstands and inchworms twice.
As soon as robot 4 is done inchworming, we want robots 1, 2, and 3 to unstand as well.
We do this by using a non-blocking continuous move function, \texttt{moveContinuousNB()}.
While the group is moving, we unstand robot 4 and inchworm it twice. After robot 4 is
done inchworming, we unstand Group D.
\begin{verbatim}
/* Make robot 4 unstand and inchworm while the remaining robots spin. */
groupD.moveContinuousNB(ROBOT_FORWARD, ROBOT_HOLD, ROBOT_HOLD, ROBOT_FORWARD);
robot4.motionUnstand();
robot4.motionInchwormLeft(2);
groupD.motionUnstand();
\end{verbatim}

\section{Data Acquisition, Data Processing, and Application Examples for Learning Algebra}
\subsection{Example 1}
\subsubsection{Problem Statement}
Roll a robot forward by rotating the wheels 720 degrees at a constant speed of 45 degrees per
second. Record the motion of joint 1 during the motion and display a plot
of the joint angle versus time. The motion should show that the joint angle $\theta$
is a linear function of time in the form $\theta = 45t$.

\subsubsection{\texttt{dataAcquisition.ch} Source Code}
\verbatiminput{../demos/chdemos/dataAcquisition.ch}

\subsubsection{\texttt{dataAcquisition.ch} Explained}
The first block of code,
\begin{verbatim}
#include <mobot.h>
#include <chplot.h>
#include <numeric.h>
CMobot robot;

/* Connect to the robot */
robot.connect();
\end{verbatim}
includes header files and declares our robot variable. The header file
\texttt{chplot.h} is necessary for plotting figures, which will be done later in the
program. The header file \texttt{numeric.h} is necessary for creating and manipulating
computational arrays, which are also used in this program. Both plotting and computational
arrays are are covered in the Ch User's Guide.

Next some variables are declared. First, we declare a variable to hold our
desired speed:
\begin{verbatim}
double speed = 45; /* Degrees/second */
\end{verbatim}
Now we declare a variable to hold the angle we want to rotate our faceplate joints:
\begin{verbatim}
double angle = 720; /* Degrees */
\end{verbatim}
And another variable to hold our polling interval:
\begin{verbatim}
double timeInterval = 0.1; /* Seconds */
\end{verbatim}
The variable \texttt{timeInterval} holds the time in seconds between data acquisition
events. The value 0.1 indicates that new data should be acquired from the robot
every 0.1 seconds, or ten times a second, in other words. Lower values will result in faster
rates of data acquisition and smoother plots. 

Next, we need to determine how long to record the data. This requires us to estimate the 
amount of time our motion will take. We will perform a motion in which the wheels of the
robot turn 720 degrees at 45 degrees a second. To find the amount of time the movement 
will take, we can use the formula
\begin{equation*}
t = \frac{\theta}{\omega}
\end{equation*}
where $\theta$ is the angle to turn the joint and $\omega$ is the speed at which the
joint is turning. The line
\begin{verbatim}
double movementTime = angle / speed; /* Seconds */
\end{verbatim}
performs this calculation and stores the result in a variable called \texttt{movementTime}.

Because physical systems are never mathematically precise, we must account for some
potential fluctuations during the motion of the robot. Because we want to be sure 
to record the motion in its entirety, it is beneficial to record for a timespan that
is actually longer than the estimated movement time. The next line:
\begin{verbatim}
movementTime = movementTime + 1; 
\end{verbatim}
adds another second to the estimated movement time.

Finally, we calculate the number of data points which will be captured during our 
recording session. This information is necessary so that we know how big to make
the computational arrays which will be used to store the data. The number
of data points can be determined by the formula
\begin{equation*}
N = \frac{t}{\Delta t}
\end{equation*}
where $t$ is the total movement time and $\Delta t$ is the time interval between
readings. We declare a new variable based on the previous equation called \texttt{numDataPoints} with 
the following line of code:
\begin{verbatim}
int numDataPoints = movementTime / timeInterval; /* Unitless */
\end{verbatim}

Next, we declare some computational arrays to hold the data we will record.
\begin{verbatim}
array double time[numDataPoints];
array double angles1[numDataPoints];
\end{verbatim}
Note that we have used the variable \texttt{numDataPoints} to specify the size
of our arrays. The \texttt{recordAngle()} function, used later to record the data,
requires two arrays to store data. The first array will store a series of timestamps
for each data point. Timestamps are stored for greater accuracy of the data. Although
the user is able to request a certain time interval, wireless and communication 
uncertainties may contribute to some fluctuation in communication times and speeds. 
In order to ensure accurate data, as the Mobot sends joint data to the computer, 
the Mobot will place an accurate timestamp on each piece of data as it was recorded
on the Mobot itself. These timestamps are stored in the \texttt{time} array and
the joint angles will be stored in the \texttt{angles1} array.

The last variables we will declare are related to generating a plot to display
the captured data. 
\begin{verbatim}
CPlot plot1, plot2, plot3;
array double angles1Unwrapped[numDataPoints];
\end{verbatim}
The variables \texttt{plot1} and \texttt{plot2} will hold the two plots we will
generate, and the computational array \texttt{angles1Unwrapped} will hold
the ``unwrapped'' data recorded from the robot. More discussion regarding
unwrapping data will be presented towards the end of this demo.

Finally, the last variable declared is \texttt{tolerance}. This variable 
holds a value in degrees. This tolerance declared here is the tolerance used
later to detect the time where motion first begins. Because the data recording 
process typically starts a fraction of a second before the motion begins, the
plotted motions may not begin at time zero. When detecting the time of the
first motion, if any joint moves by an amount more than the tolerance value, 
that time is taken to be the beginning of the motion.

Before we begin the robot's motion, we first move it to zero position and set the
joints to the correct speeds with the following lines of code:
\begin{verbatim}
/* Start the motion. First, move robot to zero position */
robot.moveToZero();
/* Set the joint 1 speed to 45 degrees/second */
robot.setJointSpeed(ROBOT_JOINT1, speed);
robot.setJointSpeed(ROBOT_JOINT4, speed);
\end{verbatim}

Next, we start capturing the data by using the \texttt{recordAngle()} function:
\begin{verbatim}
robot.recordAngle(ROBOT_JOINT1, time, angles1, numDataPoints, timeInterval);
\end{verbatim}

The recording process begins immediately and continues in the background. Now,
we may perform the motion we wish to record, which is to simply rotate each of
the faceplates by the amount desired:
\begin{verbatim}
robot.move(angle, 0, 0, angle);
\end{verbatim}

After we have performed all of our motions, we need to ensure that the recording
process which had been running in the background is completed. We used the function
\texttt{recordWait()} to make the program wait for any currently recording tasks
to finish:
\begin{verbatim}
robot.recordWait();
\end{verbatim}

After data has been recorded, we use our previously declared plotting variables to 
generate plots of the data. We will generate two separate plots. First, we simply
plot the original raw data directly from the Mobot.
\begin{verbatim}
plot1.title("Original Data for Joint Angle 1 versus Time");
plot1.label(PLOT_AXIS_X, "Time (seconds)");
plot1.label(PLOT_AXIS_Y, "Angle (degrees)");
plot1.data2D(time, angles1);
plot1.grid(PLOT_ON);
plot1.plotting();
\end{verbatim}
The previous lines of code set the plot title, set the X-axis label, set the Y-axis label,
insert the plot data, turn the grid on, and plot the data, respectively. The plot
that is generated is shown in Figure \ref{fig:dataacq1_fig1}. 

\begin{figure}[H]
\centering
\includegraphics[width=4in]{images/dataacq1_plot1.png}
\caption{\label{fig:dataacq1_fig1} The original data recorded by \texttt{dataAcquisition.ch}.}
\end{figure}

Figure \ref{fig:dataacq1_fig1} appears to show
a zig-zag pattern for the angle of the joint. This is because the raw angle data obtained
from a Mobot is only in the range -180 degrees to 180 degrees. When a joint rotates
past 180 degrees, the angle reading switches over -180 degrees. In order to get rid of the
zig-zagging of the data, the data must be ``unwrapped''. This is done with the \texttt{unwrapdeg()}
function, as done in the following line of code:
\begin{verbatim}
unwrapdeg(angles1_unwrapped, angles1);
\end{verbatim}
The function places the unwrapped version of the \texttt{angles1} array into our array
\texttt{angles1\_unwrapped}. Next, we plot the unwrapped data in a similar method 
to plotting our wrapped data:
\begin{verbatim}
plot2.title("Unwrapped Data for Joint Angle 1 versus Time");
plot2.label(PLOT_AXIS_X, "Time (seconds)");
plot2.label(PLOT_AXIS_Y, "Angle (degrees)");
plot2.data2D(time, angles1_unwrapped);
plot2.grid(PLOT_ON);
plot2.plotting();
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=4in]{images/dataacq1_plot2.png}
\caption{\label{fig:dataacq1_fig2} The unwrapped data recorded by \texttt{dataAcquisition.ch}.}
\end{figure}

Figure \ref{fig:dataacq1_fig2} displays the unwrapped data. It shows the motion as 
one fluid motion starting at 0 degrees and ending at 720 degrees. 

Finally, we want to generate a plot where the beginning of the motion correctly starts
at time 0. Looking at Figure \ref{fig:dataacq1_fig2}, you will notice that there is about
a fraction of a second delay before the joints actually start moving. For our final plot, we want
to display a plot of the same data, but shifted to the left so that the motion starts at
time zero. This will make it easier to verify the speed of the joint and the time it takes
to get to 720 degrees. 

To do this, we use the \texttt{shiftTime()} function. The \texttt{shiftTime()} function
is used to shift graphs of data to the left by detecting the first moment a joint begins
moving. The following code shifts the data to the left so that it appears that the motion begins
right at time 0.
\begin{verbatim}
shiftTime(tolerance, numDataPoints, time, angles1Unwrapped);
\end{verbatim}

Finally, we plot the shifted data.

\begin{verbatim}
plot3.title("Unwrapped and shifted Data for Joint Angle 1 versus Time");
plot3.label(PLOT_AXIS_X, "Time (seconds)");
plot3.label(PLOT_AXIS_Y, "Angle (degrees)");
plot3.data2D(time, angles1_unwrapped);
plot3.grid(PLOT_ON);
plot3.plotting();
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=4in]{images/dataacq1_plot3.png}
\caption{\label{fig:dataacq1_fig3} The unwrapped and shifted data recorded by \texttt{dataAcquisition.ch}.}
\end{figure}

Figure \ref{fig:dataacq1_fig3}  displays our unwrapped data that has been time shifted. It can be seen
that the beginning of the motion now happens at time 0, and it may be verified that the
line generated is very close to the expected function, $\theta = 45 t$.

In many applications, the user may only be interested in the unwrapped, time shifted data. 
In such a case, a simplified version of the program may be used. The program 
\texttt{dataAcquisition1.ch} below removes the intermediate plots and can be modified
to solve other data acquisition problems.

\subsubsection{\texttt{dataAcquisition1.ch} Source Code}
\verbatiminput{../demos/chdemos/dataAcquisition1.ch}

\subsection{Example 2}
It is also possible to record the joint angles for all four joints simultaneously
with the \texttt{recordAngles()} function. The function is conceptually similar
to \texttt{recordAngle()}, except that it obtains 4 joint angles for each timestamp.

\subsubsection{Problem Statement}
Record and plot the motion of all 4 joints of the Mobot as it performs the
following two motions:
\begin{enumerate}
\item Turn right by rotating joints 360 degrees.
\item Inchworm to the left twice.
\end{enumerate}

\subsubsection{\texttt{dataAcquisition2.ch} Source Code}
\verbatiminput{../demos/chdemos/dataAcquisition2.ch}

\subsubsection{\texttt{dataAcquisition2.ch} Explained}
Similar to the previous data acquisition demo, we begin by including
header files, declaring our robot variable, and connecting to the robot:
\begin{verbatim}
#include <mobot.h>
#include <chplot.h>
#include <numeric.h>
CMobot robot;

/* Connect to the robot */
robot.connect();
\end{verbatim}

We also set our data acquisition interval, movement time, and calculate
the number of data points:
\begin{verbatim}
double timeInterval = 0.1; /* Seconds */

/* Record for 20 seconds */
double movementTime = 20;
int numDataPoints = movementTime / timeInterval; /* Unitless */
\end{verbatim}
For this motion, the value of 20 seconds was decided through trial-and-error.
For complex motions such as inchworming, it is difficult to accurately estimate the 
amount of time the motion will take to complete. Through experimentation and experience,
it was determined that 20 seconds allowed for a sufficient amount of time to record the 
turning motion and the inchworming motion. 

Next, we declare our computational arrays for storing data and plotting, similar to 
the previous demo. One main difference is we declare a separate computational array
to store data for each joint angle.
\begin{verbatim}
/* Initialize the arrays to be used to store data */
array double time[numDataPoints];
array double angles1[numDataPoints];
array double angles2[numDataPoints];
array double angles3[numDataPoints];
array double angles4[numDataPoints];

/* Declare plotting variables */
CPlot plot1, plot2;
array double angles1_unwrapped[numDataPoints];
array double angles2_unwrapped[numDataPoints];
array double angles3_unwrapped[numDataPoints];
array double angles4_unwrapped[numDataPoints];
double tolerance = 1.0; /* 1 degree for time shifting */
\end{verbatim}

Before we begin the motion, we set all the joint speeds to 45 degrees/second
and move the robot into its zero postition.
\begin{verbatim}
/* Set all joint speeds to 45 degrees/second */
robot.setJointSpeeds(45, 45, 45, 45);

/* Start the motion. First, move robot to zero position */
robot.moveToZero();
\end{verbatim}

Next, we begin recording the data.
\begin{verbatim}
robot.recordAngles(time, angles1, angles2, angles3, angles4, numDataPoints, timeInterval);
\end{verbatim}

Similar to \texttt{recordAngle()}, the recording process occurs in the background as
the main program continues. We next execute our desired motions:
\begin{verbatim}
robot.motionTurnRight(360);
robot.motionInchwormLeft(2);
\end{verbatim}

Finally, we wait for the recording to finish.
\begin{verbatim}
robot.recordWait();
\end{verbatim}

Now that all of the data has been acquired, we unwrap, shift, and plot the data.
\begin{verbatim}
unwrapdeg(angles1_unwrapped, angles1);
unwrapdeg(angles2_unwrapped, angles2);
unwrapdeg(angles3_unwrapped, angles3);
unwrapdeg(angles4_unwrapped, angles4);
/* Shift the time so the movement starts at time 0 */
shiftTime(tolerance, numDataPoints, time, 
          angles1_unwrapped, 
          angles2_unwrapped, 
          angles3_unwrapped, 
          angles4_unwrapped);
plot2.title("Unwrapped Data for Joint Angles versus Time");
plot2.label(PLOT_AXIS_X, "Time (seconds)");
plot2.label(PLOT_AXIS_Y, "Angle (degrees)");
plot2.data2D(time, angles1_unwrapped);
plot2.data2D(time, angles2_unwrapped);
plot2.data2D(time, angles3_unwrapped);
plot2.data2D(time, angles4_unwrapped);
plot2.legend("Joint 1", 0);
plot2.legend("Joint 2", 1);
plot2.legend("Joint 3", 2);
plot2.legend("Joint 4", 3);
plot2.grid(PLOT_ON);
plot2.plotting();
\end{verbatim}
Note that the previous call to \texttt{shiftTime()} appears different than the previous
example. The \texttt{shiftTime()} function is able to accept any number of data
arrays per time array to shift. The function tests the tolerance angle on all of the
input data arrays, seeking the first occurance of a movement greater than the tolerance
for all of the data arrays. This makes the plotted motion begin right at time 0 on
the plot.

\begin{figure}[H]
\centering
\includegraphics[width=4in]{images/dataacq2_plot1.png}
\caption{\label{fig:dataacq2_fig1} The unwrapped and shifted data recorded by \texttt{dataAcquisition2.ch}.}
\end{figure}

Figure \ref{fig:dataacq2_fig1} shows the captured data from the Mobot. During the first
part of the motions, joints 1 and 4 move in opposite directions to rotate the robot to
the right. After rotating 360 degrees, joints 2 and 3 move to inchworm the robot to the
left twice.

\subsection{Example 3}
\subsubsection{Problem Statement}
A robot is equipped with 3.5 inch diameter wheels. Write a piece of code which rolls the
robot forward at 2.5 inches per second for a distance of 12 inches. 

\subsubsection{\texttt{dataAcquisition3.ch} Source Code}
\verbatiminput{../demos/chdemos/dataAcquisition3.ch}

\subsubsection{\texttt{dataAcquisition3.ch} Explained}
The first lines include header files and set up the robot similar to the previous
demos:
\begin{verbatim}
#include <mobot.h>
#include <chplot.h>
#include <numeric.h>
CMobot robot;

/* Connect to the robot */
robot.connect();
\end{verbatim}

Next, we initialize some variables. First, we make a variable to store the speed
we want to move the robot.
\begin{verbatim}
double speed = 2.5; /* inches / second */
\end{verbatim}

Next, a variable for the distance.
\begin{verbatim}
double distance = 12; /* inches */
\end{verbatim}

And a variable for the wheel radius...
\begin{verbatim}
double radius = 3.5/2.0; /* inches */
\end{verbatim}

Now we wish to calculate the angle that the wheels need to turn in order to
travel a distance of 12 inches. To do this, we use a function called
\texttt{distance2angle()}. The \texttt{distance2angle()} function 
takes a wheel radius and the distance as arguments and returns the angle
the wheel must turn to travel that distance. 
\begin{verbatim}
double angle = distance2angle(radius, distance); /* degrees */
\end{verbatim}

Internally, the angle in degrees is calculated by the formula
\begin{equation*}
\theta  = \left(\frac{d}{r} \right) * 180 / \pi
\end{equation*}
where $\theta$ is the angle in degrees, $d$ is the distance travelled, 
and $r$ is the radius of the wheel.

For the next step, we must calculate our estimated movement time, similar to the
\texttt{dataAcquisition.ch} demo presented earlier. 
\begin{verbatim}
double movementTime = distance / speed; /* Seconds */
\end{verbatim}

Is in previous demos, we include an extra second in our movement time. We
also calculate the number of data points based on the total movement time
and the time interval.
\begin{verbatim}
movementTime = movementTime + 1; 
double timeInterval = 0.1; /* seconds */
int numDataPoints = movementTime / timeInterval; /* Unitless */
\end{verbatim}

Now, we allocate our computational arrays for storing data. We have arrays 
for the time, angles, and also distances.
\begin{verbatim}
array double time[numDataPoints];
array double angles1[numDataPoints];
array double distances[numDataPoints];

/* Declare plotting variables */
CPlot plot;
array double angles1Unwrapped[numDataPoints];
double tolerance = 1.0; /* Degrees */
\end{verbatim}

Before beginning the motion, we move the robot to zero position and set the 
wheel speeds.
\begin{verbatim}
/* Start the motion. First, move robot to zero position */
robot.moveToZero();
/* Set robot wheel speed */
robot.setTwoWheelRobotSpeed(speed, radius);
\end{verbatim}

Start recording the angle of the first joint.
\begin{verbatim}
robot.recordAngle(ROBOT_JOINT1, time, angles1, numDataPoints, timeInterval);
\end{verbatim}

Move the robot forward by the angle calculated earlier with \texttt{distance2angle()}.
\begin{verbatim}
robot.motionRollForward(angle);
\end{verbatim}

Wait for the recording to finish.
\begin{verbatim}
robot.recordWait();
\end{verbatim}

Finally, we want to unwrap and shift the data and convert the angle readings to a distance.
The unwrap and shifting process is identical to Example 1 of this section. 
We convert the angles back to a distance using the \texttt{angle2distance()} function,
which takes the radius of a wheel and the angle moved in degrees as arguments and
return the distance traveled. The arguments can be single variables or computational
arrays. If the angle argument is a computational array, the value returned is also
a computational array. The \texttt{angle2distance()} function converts the angle
to a distance using the following formula.
\begin{equation*}
d = \left(\theta \frac{180}{\pi}\right) r
\end{equation*}
where $d$ is the distance travelled, $\theta$ is the angle rotated, and $r$ is the
radius of the wheel. The units of distance for $d$ will be the same units as those
chosen for $r$. For instance, if $r$ is expressed in inches, the result 

\begin{verbatim}
/* Unwrap the data */
unwrapdeg(angles1_unwrapped, angles1);
/* Shift the data */
shiftTime(tolerance, numDataPoints, time, angles1Unwrapped);
/* Convert angles to displacement */
distances = angle2distance(radius, angles1Unwrapped);
\end{verbatim}

Finally, we create a plot of the data.
\begin{verbatim}
plot.title("Displacement versus Time");
plot.label(PLOT_AXIS_X, "Time (seconds)");
plot.label(PLOT_AXIS_Y, "Displacement (inches)");
plot.data2D(time, distances);
plot.grid(PLOT_ON);
plot.plotting();
\end{verbatim}

\begin{figure}[H]
\centering
\includegraphics[width=4in]{images/dataacq3_plot1.png}
\caption{\label{fig:dataacq3_fig1} The unwrapped data recorded by \texttt{dataAcquisition2.ch}.}
\end{figure}

Figure \ref{fig:dataacq3_fig1} displays the distance data acquired during the motion. It can
be seen that the robot traveled to a distance of 12 inches, and then stopped. The
expected relation between time and distance is the linear function 
\begin{equation*}
d = 2.5t
\end{equation*}
which may be verified on the graph. Furthermore, the time that it should take to reach 
12 inches is 
\begin{equation}
t = d / 2.5 = 12 / 2.5 = 4.8 \text{seconds}
\end{equation}
which may also be verified from the graph.

\section{Recalibrating the Mobot}
A user may recalibrate the Mobot's zero positions if necessary. To recalibrate
the Mobot, perform the following steps:
\begin{itemize}
\item Press both of the Mobot's ``A'' and ``B'' buttons simultaneously. The
blue status LED light on the Mobot should blink several times and then remain
off.
\item Power off the Mobot.
\item Manually move the Mobot joints into the correct zero position, as shown in Figure \ref{fig:zeroposition}. This may be
done visually, or by using flat surfaces as a guide.
\item Power on the Mobot while it is in the correct zero position. After calibration,
the Mobot will perform a short movement routine to test all of its joints. The
Mobot has now been recalibrated.
\end{itemize}

\newpage
\appendix
\section{\label{sec:datatypes}Data Types}
The data types defined in the header file \texttt{mobot.h} are described in
this appendix.
These data types are used by the Mobot library to represent 
certain values, such as joint id's and motor directions.

\begin{tabular}{p{3.5cm}p{10cm}} \hline 
Data Type& Description \\
\hline 
\texttt{robotJointId\_t} & An enumerated value that indicates a Mobot joint. \\
\texttt{robotJointState\_t} & The current state of a Mobot joint. \\
\hline
\end{tabular}

\subsection{\label{sec:robotJointId_t}\texttt{robotJointId\_t}}
This datatype is an enumerated type used to identify a joint on the Mobot. Valid
values for this type are:
\begin{verbatim}
typedef enum mobot_joints_e {
  ROBOT_JOINT1 = 1,
  ROBOT_JOINT2 = 2,
  ROBOT_JOINT3 = 3,
  ROBOT_JOINT4 = 4
} robotJointId_t;
\end{verbatim}
\index{robot\_joints\_t}

\index{ROBOT\_JOINT1}
\index{ROBOT\_JOINT2}
\index{ROBOT\_JOINT3}
\index{ROBOT\_JOINT4}
\begin{tabular}{p{3cm}p{10cm}} \hline 
Value & Description \\
\hline 
\texttt{ROBOT\_JOINT1} & Joint number 1 on the Mobot, which is a faceplate joint. \\
\texttt{ROBOT\_JOINT2} & Joint number 2 on the Mobot, which is a body joint. \\
\texttt{ROBOT\_JOINT3} & Joint number 3 on the Mobot, which is a body joint. \\
\texttt{ROBOT\_JOINT4} & Joint number 4 on the Mobot, which is a faceplate joint. \\
\hline
\end{tabular}

\subsection{\label{sec:robotJointState_t}\texttt{robotJointState\_t}}
This datatype is an enumerated type used to designate the current 
movement state of a joint. The values may be retrieved from the 
robot with the \texttt{getJointState()} function and may be set 
with the \texttt{moveContinuous()} family of functions. Valid values are:

\begin{verbatim}
typedef enum mobot_joint_state_e {
  ROBOT_NEUTRAL   = 0,
  ROBOT_FORWARD   = 1,
  ROBOT_BACKWARD  = 2,
  ROBOT_HOLD      = 3
} robotJointState_t;
\end{verbatim}

\begin{tabular}{p{3.3cm}p{11.5cm}} \hline 
Value & Description \\
\hline
\texttt{ROBOT\_NEUTRAL}& This value indicates that the joint is not moving and is not actuated. The joint is freely backdrivable. \\
\texttt{ROBOT\_FORWARD}& This value indicates that the joint is currently moving forward. \\
\texttt{ROBOT\_BACKWARD}& This value indicates that the joint is currently moving backward. \\
\texttt{ROBOT\_HOLD}& This value indicates that the joint is currently not moving and is holding its current position. The joint is not currently backdrivable. \\
\hline
\end{tabular}

\section{\label{sec:cmobot_api}CMobot API}
\input{api/libimobotcomms.tex}

\section{\label{sec:cmobotgroup_api}CMobotGroup API}
\input{cmobotgroup_api/cmobotgroup.tex}
% Index
%\addcontentsline{toc}{chapter}{Index}

\section{\label{sec:utility_functions}Miscellaneous Utility Functions}
\input{utility_funcs/utility_funcs.tex}
\printindex

\end{document}
