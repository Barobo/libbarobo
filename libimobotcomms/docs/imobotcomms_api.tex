\documentclass{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{makeidx}

\title{Programming the iMobot}  
%\author{David Ko\\Mechanical and Aerospace Engineering}
%\date{\today} 
\makeindex

\begin{document}
\maketitle

\section{The \texttt{CMobot} iMobot Remote Control Library}
The \texttt{CMobot} library is a collection of functions geared towards
controlling the motors and reading sensor values of an iMobot module via the
Bluetooth wireless protocol. The functions are designed to be intuitive
and easy to use. Various functions are provided to control or obtain the speed,
direction, and position of the motors. The API includes C-style functions as well
as a C++ class called \texttt{CMobot} to facilitate C++ style api function
calls. 

This documentation introduces the basic computer setup required for controlling 
the iMobot, as well as several demo programs and a complete reference for all
API function provided with the \texttt{CMobot} library.

\section{\label{sec:pairing}Bluetooth Pairing with the iMobot}
To control the iMobot with the Bluetooth wireless protocol, the controlling 
computer must be equipped with Bluetooth. If the computer does not have
Bluetooth built-in, an external USB Bluetooth dongle may be used. The following
instructions are for a Windows 7 computer with built-in Bluetooth. The basic
process is the same for Windows XP and Vista, although the screenshots may
appear different. 

The first step is to open the Bluetooth applet by double-clicking the Bluetooth
icon in the applet tray normally found at the bottom right of the screen, as
shown highlighted in red in the following figure.

\begin{center}
\includegraphics[width=3in]{images/imobot_connect_1.png}
\end{center}

After double-clicking the icon, a new window will appear similar to the following.

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_1a.png}
\end{center}

Next, click on the
button labeled "Add Wireless Device" towards the top of the window. This 
will bring up the following dialog.

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_2.png}
\end{center}

This dialog shows a list of all Bluetooth wireless devices that are in range.
Among them should be the iMobot you wish to connect to. If the iMobot does not
appear on this list, please ensure that the iMobot is within 10 meters of the
connecting computer and that the iMobot is powered on. Double click on the icon
representing the iMobot to proceed. Once you have double-clicked the icon, the
following dialog box should appear.

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_3.png}
\end{center}

Select the second option, labeled ``Enter the device's pairing code''. iMobot
modules come hard-coded with a default pairing code. When prompted for the
pairing code, enter ``1234''. Once the computer is paired with the iMobot,
the following dialog box may pop up asking to install drivers.

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_4.png}
\end{center}

If the previously illustrated dialog box appears, just click the ``cancel''
button at the bottom right. No extra drivers are necessary for controlling the
iMobot module.

At this point, the following dialog should be shown.

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_6.png}
\end{center}

The next step is to enable the iMobot control service. 
Double-click on the icon denoting the
iMobot module to bring up the following dialog:

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_7.png}
\end{center}

Click on the tab labeled ``Services''

\begin{center}
\includegraphics[width=5in]{images/imobot_connect_8.png}
\end{center}

Ensure that the service titled ``iMobot Control'' is enabled. If it is not
enabled, click on the check-box to enable it. Click on the ``Ok'' button to
accept the changes and close the dialogs. The iMobot is now ready to be
controlled with the iMobotComms library.

\section{ The MoBot Remote Control Program }
\includegraphics[width=4.5in]{images/iMobot_controller_screenshot.png}

The preceding figure shows the MoBot remote control program. The
program displays a graphical interface which may be used to display
information about the iMobot's joint positions, and also control the
speeds and positions of the MoBot's joints. The interface is divided
up into six sections; three on the top half of the interface, and three on 
the bottom half. 

\subsection{The iMobot Diagram and ``Move To Zero'' Button}
The first section of the GUI located on the top left of the interface
displays a schematic diagram of the iMobot, displaying motor positions.
Underneath the diagram, there is a large button with the text 
``Move To Zero''. When clicked, this button will command the connected
MoBot to rotate all of its joints to a flat ``Zero'' position.

\subsection{Individual Joint Control}
The second section, located at the top-middle section of the interface,
is the ``Individual Joint Control'' section. These buttons command the
MoBot to move individual joints. When the up or down arrows are clicked,
the MoBot begins to move the corresponding joint in either the positive,
or negative direction. The joint will continue to move until the stop 
button, located between the up and down arrows, is clicked. 

\subsection{Rolling Control}
This section contains buttons for controlling the iMobot as a 
two wheeled mobile robot. The up and down buttons cause the MoBot to
roll forward or backward. The left and right buttons cause the MoBot 
to rotate towards the left, or towards the right. The stop button in the
middle causes the MoBot to stop where it is.

\subsection{Joint Speeds}
The ``Joint Speeds'' section, located at the bottom left of the interface,
displays and controls the current joint speeds of the MoBot. Joint speeds
are a value between 0 and 1, with 1 meaning maximum joint power, and 0
meaning zero joint power. The speed may be set by sliding the vertical 
sliders to the desired positions. 

\subsection{Joint Positions}
This section, located in the bottom-middle of the interface, is used to display
and control the positions of each of the four
joints of a MoBot. The joint positions are displayed in the numerical
text located above each vertical slider. The displayed joint positions are in
units of degrees.  There are two methods to control
the joints using this interface.

The first method of controlling the joints is by using the vertical sliders.
Each vertical slider's position represents a joint's angle. The sliders for the
two end joints vary from -180 degrees to 180 degrees, representing one complete
rotation. The angles for the two body joints vary from -90 to 90 degrees. When
the position of the slider is moved, the MoBot will move its joints to match the 
sliders. 

The second method for moving the joints is by entering the exact angles for the
joints. Below each of the four sliders lies a text entry box. Values in degrees
may be typed into each of the four entry boxes. When the button on the lower
right of the section labeled ``Move'' is clicked, the MoBot will move its joints
to match the values typed into the boxes. If no value is typed into a box, that 
joint will not move.

\subsection{Motions}
This section, located on the bottom right of the interface, contains a set of
preprogrammed motions for the MoBot. To execute a preprogrammed motion, simply
click on the name of the motion you wish to execute, and then click the button
labeled ``Play''.

\section{Basics of a Ch iMobot Program}
To help the user become acquainted with the iMobot control programs, one sample
program will be presented to illustrate the basics and minimum requirements of
an iMobot control program. 

\subsection{\texttt{getting\_started.ch} Source Code}
\verbatiminput{../demos/getting_started/getting_started.ch}

\subsection{\label{sec:democode}Demo Code for \texttt{getting\_started.ch} Explained}
The beginning of every iMobot control program will include header files. Each
header file imports functions used for a number of tasks, such as printing
data onto the screen or controlling the iMobot. 

\begin{verbatim}
#include <mobot.h> // Required for iMobot control functions
\end{verbatim}

Next, we must initialize the C++ class used to control the iMobot. This line
initializes a new variable named \texttt{robot} which represents the remote
iMobot module which we wish to control. This special variable is actually an
instance of the \texttt{CMobot} class, which contains its own set of
functions called ``methods'' or ``member functions''.
\begin{verbatim}
CMobot robot;
\end{verbatim}
Note that there is an alternative way to create the \texttt{robot} variable.
The alternate method takes the following syntax:
\begin{verbatim}
CMobot robot("12:34:56:78:90:12", 20);
\end{verbatim}
The alternate syntax instructs the new \texttt{CMobot} variable named 
\texttt{robot} to explicitely connect to the robot with address
\texttt{"12:34:56:78:90:12"} and channel \texttt{20}. This method allows
the iMobot program to connect to an iMobot even if it has not been paired,
as described in Section \ref{sec:pairing}. However, it requires the user
to know the Bluetooth address of the iMobot in advance.

The next line will use the \texttt{moveToZero} member function. The
\texttt{moveToZero} function causes the iMobot to move all of its motors to the
zero position.
\begin{verbatim}
robot.moveToZero();
\end{verbatim}

The majority of iMobot control functions do not wait for the robotic motions to
complete before continuing. As such, if we want to wait for the robot to fully
complete the requested motion before continuing with the rest of the program,
we must use the \texttt{moveWait} function, as such.
\begin{verbatim}
robot.moveWait();
\end{verbatim}

The next four lines of code command joints 1 and 4 to rotate 90 degrees, and
then waits for the motors to stop moving. Joints 1 and 4 are the faceplates
of the iMobot which are sometimes used to act as "wheels".
\begin{verbatim}
robot.moveJointTo(IMOBOT_JOINT1, 90);
robot.moveJointTo(IMOBOT_JOINT4, 90);
robot.moveJointWait(IMOBOT_JOINT1);
robot.moveJointWait(IMOBOT_JOINT4);
\end{verbatim}

\section{Preprogrammed Motions}
The MoBot API contains functions for executing preprogrammed motions. The 
preprogrammed motions are motions which are commonly used for MoBot locomotion.
Following is a list of available functions and a brief description about
their effect on the MoBot.
\begin{itemize}
\item \texttt{motionInchwormLeft()}: This function causes the MoBot to perform
  the inchworm gait once, moving the MoBot towards its left.
\item \texttt{motionInchwormRight()}: This function causes the MoBot to perform
  the inchworm gait once, moving the MoBot towards its right.
\item \texttt{motionRollBackward()}: This function causes the MoBot to rotate
  its faceplates, using them as wheels to roll backward.
\item \texttt{motionRollForward()}: This function causes the MoBot to rotate
  its faceplates, using them as wheels to roll forward.
\item \texttt{motionStand()}: This function causes the MoBot to stand up onto a 
  faceplate, assuming the camera platform position.
\item \texttt{motionTurnLeft()}: Uses the MoBot's faceplates as wheels, turning
  them in opposite directions in order to rotate the MoBot towards its left.
\item \texttt{motionTurnRight()}: Uses the MoBot's faceplates as wheels, turning
  them in opposite directions in order to rotate the MoBot towards its right.
\end{itemize}

\section{Blocking and Non-Blocking Functions}
All of the MoBot movement functions may be designated as either ``blocking'' 
functions or ``nonblocking'' functions. A blocking function is a function which
does not return while operations are being performed. For instance, the
\texttt{moveWait()} function is a blocking function. When called, the function
will hang, or ``block'', until all the joints have stopped moving.

Furthermore, some functions have both a blocking version and a non-blocking
version. For these functions, the suffix \texttt{NB} denotes that the function
is non-blocking. For instance, the function \texttt{motionStand()} is blocking,
meaning the function will not return until the motion is completed, whereas
the function \texttt{motionStandNB()} is non-blocking, meaning the function
returns immediately and the robot performs the ``standing'' motion
asynchronously.

The function \texttt{move()} is an example of a non-blocking function. When
the \texttt{move()} function is called, the function immediately returns 
as the joints begin moving. The next statement in the program is executed
even before the movement has completed. 

\subsection{List of Non-Blocking Movement Functions}
\begin{itemize}
\item \texttt{move()}
\item \texttt{moveContinuous()}
\item \texttt{moveJointTo()}
\item \texttt{moveTo()}
\item \texttt{moveToZero()}
\item \texttt{motionInchwormLeftNB()}
\item \texttt{motionInchwormRightNB()}
\item \texttt{motionRollBackwardNB()}
\item \texttt{motionRollForwardNB()}
\item \texttt{motionStandNB()}
\item \texttt{motionTurnLeftNB()}
\item \texttt{motionTurnRightNB()}
\end{itemize}

\subsection{List of Blocking Movement Functions}
\begin{itemize}
\item \texttt{moveContinuousTime()}
\item \texttt{moveJointWait()}
\item \texttt{moveWait()}
\item \texttt{motionInchwormLeft()}
\item \texttt{motionInchwormRight()}
\item \texttt{motionRollBackward()}
\item \texttt{motionRollForward()}
\item \texttt{motionStand()}
\item \texttt{motionTurnLeft()}
\item \texttt{motionTurnRight()}
\end{itemize}

\section{Controlling Multiple Modules}
The MoBot control software is designed to be able to control multiple modules
simultaneously. There are a couple important differences in the program 
which enable the control of multiple modules. A small demo program which
controls two modules simultaneously will first be presented, followed by
a detailed explanation of the program elements.

\subsection{Multiple Module Demo Program}
\verbatiminput{../demos/multiple_modules/multiple_modules.cpp}

\subsection{Demo Explanation}
The first two lines of interest appear as such:
\begin{verbatim}
  CMobot robot1;
  CMobot robot2;
\end{verbatim}
These two lines declare two separate variables which will represent the
two separate MoBot modules. Next, we need to connect each variable to
a physically separate MoBot. This is done with the following lines.
\begin{verbatim}
  robot1.connectWithAddress("11:11:11:11:11:11", 20);
  robot2.connectWithAddress("22:22:22:22:22:22", 20);
\end{verbatim}
These lines connect the first variable, \texttt{robot1}, to the MoBot with
address \texttt{11:11:11:11:11:11}. When running this demo, this
demo address will need to be replaced with the actual address of the MoBot.
The second argument, \texttt{20}, is the channel to connect to. By default,
the MoBot will listen on channel 20 for incoming connections.

A similar process is done with \texttt{robot2}, causing it to connect
to a second MoBot with address \texttt{22:22:22:22:22:22}.

\begin{verbatim}
  robot1.moveToZero();
  robot2.moveToZero();
\end{verbatim}
These two lines command the two robots to move to their zero positions.
Note that these functions are non-blocking. This means that the
\texttt{moveToZero()} function will return immediately, and will not
wait for the first robot to finish completing the motion before 
commanding the second robot to begin. In a normal program, this effectively
causes both robots to move to their zero positions simultaneously.

\begin{verbatim}
  robot1.moveWait();
  robot2.moveWait();
\end{verbatim}
Since the \texttt{moveToZero()} functions are non-blocking, we would like
the program to wait until the motions are complete before continuing. By
calling \texttt{moveWait()} on both of the robots, we can be assured that
the robots have finished moving before the program continues.

\begin{verbatim}
  robot1.motionStandNB();
  robot2.motionStandNB();
  robot1.moveWait();
  robot2.moveWait();
\end{verbatim}
Similar to the calls to \texttt{moveToZero()}, this block of code instructs 
the two MoBots to stand. Note that we call the non-blocking versions of the
stand function, called \texttt{motionStandNB()}. Since these functions are
non-blocking, both robots will effectively stand simultaneously. Again,
we call the \texttt{moveWait()} function on both robots to ensure that 
the robots have finished standing before the code continues.

\newpage
\appendix
\section{iMobotComms API}
\input{api/libimobotcomms.tex}

\section{Macros}

\subsection{\texttt{iMobot\_joints\_t}}
\index{iMobot\_joints\_t}
The data type \texttt{iMobot\_joints\_t} contains the following macro datatypes.\\

\index{IMOBOT\_JOINT1}
\index{IMOBOT\_JOINT2}
\index{IMOBOT\_JOINT3}
\index{IMOBOT\_JOINT4}
\begin{tabular}{p{3cm}p{7cm}} \hline 
Value & Description \\
\hline 
\texttt{IMOBOT\_JOINT1} & Joint number 1 on the iMobot, which is a faceplate joint. \\
\texttt{IMOBOT\_JOINT2} & Joint number 2 on the iMobot, which is a body joint. \\
\texttt{IMOBOT\_JOINT3} & Joint number 3 on the iMobot, which is a body joint. \\
\texttt{IMOBOT\_JOINT3} & Joint number 4 on the iMobot, which is a faceplate joint. 
\end{tabular}

\subsection{\texttt{iMobot\_joint\_direction\_t}}
\index{iMobot\_joint\_direction\_t}
The data type \texttt{iMobot\_joint\_direction\_t} indicates the commanded direction 
of a joint on the MoBot.

\index{IMOBOT\_NEUTRAL}
\index{IMOBOT\_FORWARD}
\index{IMOBOT\_BACKWARD}
\begin{tabular}{p{3cm}p{7cm}} \hline 
Value & Description \\
\hline 
\texttt{IMOBOT\_NEUTRAL} & This value indicates automatic direction control for a joint. 
The MoBot will choose the best direction to attain the commanded joint position. \\
\texttt{IMOBOT\_FORWARD} & Move the joint in the forward direction. \\
\texttt{IMOBOT\_BACKWARD} & Move the joint in the backward direction. \\
\end{tabular}
% Index
\section{Index}
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}
